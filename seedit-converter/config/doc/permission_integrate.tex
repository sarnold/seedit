\documentclass{article}
\title{Integrated/unsupported permissions in Simplified Policy for Ver 2.1}



\begin{document}
\def\labelenumi{(\theenumi)}
\maketitle
\tableofcontents
\newpage
Simplified Policy Description Language(SPDL) simplifies SELinux by
reducing number of permissions. This reduction is done by not supporting
permissions and integrating permissions.
This document describes what kind of permissions are not supported in
Simplified Policy Description Language(SPDL) and what kind of
permissions are integrated in SPDL rules.
{\it Not supported } means the permissions are allowd to all domains.
{\it Integrated } means permissions are treated as one permission.\\
Not supported permissions are listed in section 1. Integration of
permission is described in section 2.

\section{How to look at tables}
Permissions are listed in table format. How to look at table is explained.
\begin{enumerate}
 \item Notation to represent domain and type\\
       \begin{itemize}
	\item global\\
	      It means all domains.
	\item from,  entry, to\\	      
	      from domain, entry point, to domain in domain transition rule.
       \end{itemize}
 \item Notation to represent many permissions\\
       Following are used to describe set of permissions(it is to save space.)
       \begin{itemize}
	\item file\_type\\
	      All types for files.
       \item all\_file\_class\\
	     It means all object classes related to file(dir file
	     lnk\_file sock\_file fifo\_file chr\_file blk\_file)
	\item notdevfile\_class\\
	     Means all file related object classes except device(dir
	     file lnk\_file sock\_file fifo\_file)
	\item notdevdir\_class\\
	     Means file related object classes except device and dir(file lnk\_file sock\_file fifo\_file)
	\item notdir\_class\\
	     Means file related object classes except dir(file lnk\_file
	     sock\_file fifo\_file chr\_file blk\_file)
	\item socket\_common\_all\_perms\\
	     Permissions common to sockets(ioctl readwrite create
	     getattr setattr lock relabelfrom relabelto append bind
	     connect listen accept getopt setopt shutdown recvfrom
	     sendto recv\_msg send\_msg name\_bind )
	\item tcp\_socket\_all\_perms\\
	     Permissions common to tcp socket(ioctl read write create getattr setattr lock relabelfrom relabelto append bind connect listen accept getopt setopt shutdown recvfrom sendto recv\_msg send\_msg name\_bind connectto newconn acceptfrom node\_bind name\_connect)
	\item udp\_socket\_all\_perms\\
	     Permissions common to udp socket(ioctl read	write create getattr setattr lock relabelfrom relabelto append bind connect listen accept getopt setopt shutdown recvfrom sendto recv\_msg send\_msg name\_bind node\_bind)
       \end{itemize}

 \item Tables in section 2\\
       These tables describes what kind of permissions are not supported.
       Titles of table show why these permissions are not
       supported.
       For example, the title of table 1 is Dead permission. It means
       permissions in table is not supported because these are dead
       permission in SELinux.  Detailed reason why unsupported will be described in
       future :-)\\
       Let's see example. First line in table1, all\_file\_class,
       swapon, global , file\_type is described.
       It means, all domains(global) are allowed permission swapon for
       all object class related to file(all\_file\_class), to all types
       related to file(file\_type). It equals following allow statement
       in SELinux.
       \begin{verbatim}
       allow global file\_type:all\_file\_class swapon;	
       \end{verbatim}
       So this means, swapon permission is allowed(=not supported).
 \item Tables in section 3\\
       These tables describe how permissions are integrated in SPDL.
       Let's see example. Look at table 11. This table describes
       permissions allowed when using {\it allow filename r;} statement.       
{\it all\_file\_class, ioctl lock read, domain, type} are  described
       here.
       This means, ioctl lock read permissions for all file related
       object classes are allowed. 
\end{enumerate}


\newpage
Following  was automatically generated by genmacro.py
\input{table}
\end{document}

