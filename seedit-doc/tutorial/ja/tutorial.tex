\documentclass{article}
\usepackage[dvipdfm]{graphicx}
\usepackage[dvipdfm]{hyperref}
\AtBeginDvi{\special{pdf:tounicode EUC-UCS2}}
\title{SELinux Policy Editor(seedit)管理ガイド（マニュアル) 2.0}
\author{中村　雄一\thanks{himainu-ynakam@miomio.jp}}
\begin{document}
\def\labelenumi{(\theenumi)}
\maketitle
\tableofcontents
\newpage
 
この文書は、SELinux Policy Editor 2.0のマニュアルです。設定方法を紹介しています。
インストール方法については、インストールガイドを参照してください。

\section{背景：SELinuxの難しさ}
SELinuxは既に多くのディストリビューションに取り込まれています。しかし、
多くのユーザーはSELinuxを無効にしてきました。SELinuxは手に負えない、と感
じるユーザーが多かったからです。
SELinuxの難しさはポリシーの設定にあります。ポリシーが難しい理由は以下が
挙げられます。
\begin{itemize}
 \item 多すぎるパーミッション\\
       SELinuxのパーミッション定義は７００種類にも及びます。細かい設定が
       できる反面、必要な設定が増大します。       
 \item ラベル管理が大変\\
       SELinuxは、ファイルやポート番号などにタイプというラベルを付与し、
       アクセス制御を行います。ラベルは直感的に分かりにくい上，ファイル
       やポート番号のラベル管理の手間が生じます。
 \item 多すぎるマクロ\\
       SELinuxの設定をする際には、「マクロ」を利用して、複数行の設定を一
       行での設定をまとめて行います。しかし、マクロの種類がどんどん増え
       ています。例えば，BINDを設定するために使われているマクロだけでも、
       80種類近くに及びます。一般的なシステム管理者には、設定内容の理解
       と設定の記述は極めて困難です。
\end{itemize}

\section{SELinux Policy Editor(seedit)とは？}
\subsection{概略}
SELinux Policy Editor(略称seedit)は、SELinuxを簡単にするツールです。
seeditは、Simplified Policy(単純化ポリシー)と、Simplified Policy周辺ツー
ルから成り立つツールです。\\
最も重要な要素はSimplified Policyです。
Simplified Policyとは、Simplified Policy Description Language(単純化ポリ
シ記述言語、以下SPDL)で記述されたSELinuxのポリシのことです。SPDLは、
SELinuxの設定を大幅に簡略化します。SPDLは、セキュリティ上影響の少ないパー
ミッションを省略・統合することによってパーミッションの数を減らします。ま
た、ラベルを隠蔽し、ファイル名、ポート番号を直接使って設定できるようにし
ています。同時に、マクロ地獄からも解放
されます。\\
SPDLで記述されたポリシーが，SELinuxの設定に変換され，設定が反映されます。
\\
以下が、SPDLによって書かれたSimplified Policyの例です。Apache Webサーバーに「httpd\_t」
というドメイン（権限のこと）を割り当てて設定しています。
\begin{verbatim}
{
domain httpd_t;
program /usr/sbin/httpd;
...
allow /var/www/** r,s;
allownet -protocol tcp -port 80 server;
...
}	
\end{verbatim}
SPDLを使ったポリシーの意味は明快です。カスタマイズ、新規ポリシーの記述も簡単です。
SPDLを生成するためのツールやGUIが用意されているからです。


\subsection{seeditの歴史}
SELinux Policy Editorの元となるバージョンは、日立ソフトウェアエンジニア
リング(http://www.selinux.hitachi-sk.co.jp/)により開発され、2003年2月にGPLにて公開さ
れました。このバージョンをアップデートしたものが、バージョン1.0として2005年7月に公
開されました。\\
現バージョン(2.0)は、中村がThe George Washington Universityにて再設計し、
日立ソフトの実装を一部使いながら，再実装、新規開発したものです。

\subsection{seeditの限界}
seeditは、到達できるセキュリティレベルに限界があります。
Simplified Policyは、情報フロー分析が不可能です。
「ポリシーは、形式的（数学的）
に分析可能であるべきである」と考える人は、seeditを使ってはいけません。
SELinuxのstrictポリシーを頑張って使ってください。
情報フロー分析可能なSimplified Policyについては、現在考察を進めていると
ころです。


\section{SELinuxの背景知識}
 seeditを使う前に，SELinuxに関する最低限の知識を押さえておく必要があります。
\begin{enumerate}
 \item TE(Type-Enforcement)\\
       SELinuxのアクセス制御メカニズムはTE(Type Enforcement)と呼ばれてい
       ます。TEでは、プロセスには、ドメインと呼ばれる権限が割り当てられ
       ます。例えば、Apache Webサーバー(/usr/sbin/httpd)には、httpd\_tと
       いうドメインが割り当てられます。
ポリシーと呼ばれる設定ファイルに、ドメインがどんなリソース
       （ファイルなど）にアクセスができるかのルールが記述されています。
       リソースを識別するために、タイプと呼ばれるラベルを使います(seedit
       では隠蔽されます)。
       全てのプロセスは、ポリシーに記述された通りのドメインを
       与えられ，その権限の範囲内だけで動作します。
       SELinuxの鍵となるのは、どんなドメインを割り当てるか、ドメインにど
       んなアクセスを許可するか、というポリシーの設定となります。\\
       なお、ドメインの割り当てられるタイミングは、実行ファイルの実行時になります。ポ
       リシーファイルに、「実行ファイルを実行した場合、特定のドメインを
       割り当てる」と書いてある場合のみ、ドメインが割り当てられます。
       あるアプリケーションに割り当てるドメイン名を変更した場合は、アプ
       リケーションの再起動が必要になるのに注意が必要です。
       ドメイン名を変えず、ドメインの持つ権限のみを変えた場合はアプリケー
       ションの再起動は
       不要です。
 \item Enforcing/permissive モード\\
       SELinuxには、enforcingモード、permissiveモードと呼ばれる２つのモー
       ドが用意されています。\\
       Enforcingモードは通常のモードです。ポリシーに書かれたアクセス制御
       設定が有効な状態です。\\
       Permissiveモードは、テストモードとも言えるモードです。SELinuxによっ
       て拒否されるアクセスがあったとしても，それは拒否されず，ログにア
       クセス拒否の事実が記述されるだけ、というモードです。 Permissiveモー
       ドでは、アプリケーションは通常のLinuxと同様に動きます。が、アプリ
       ケーションがどんなアクセスをするのか挙動を調べ、ポリシーを書くの
       に役立ちます。
       現在のモードを確認するには、{\it getenforce}コマンドを使います。
       enforcing/permissiveモードの切り替えには、{\it
       setenforce} コマンドを使います。使い方は、後で紹介します。
 \item SELinuxのアクセス拒否ログ\\
       SELinuxによってアクセスが拒否された場合、Fedora Core5の場合、
       /var/log/messagesにアクセス拒否ログが出ます。dmesgコマンドでも閲
       覧可能です。Fedora Core4や、auditdサービスが動作している場合は，
       /var/log/audit/audit.logにログが出力されることに気を付けます。
\end{enumerate}



\section{GUIの概要}
GUIを使うことで、より簡単にSELinuxを使うことができます。
X Window Systemから、「seedit-gui」または「デスクトップ→管理→
SELinux Policy Editor」または、コンソールから「seedit-gui」とすることでGUIが起動
します。
すると、
 {\it SELinux Policy Editor コントロールパネル}という画面が開きます。
このコントロールパネルには、アイコンが 図\ref{fig:controlpanel}のように
並んでいます(CentOS 4では、アイコンの代わりにボタンが表示されます)。 \\

\begin{figure}
\caption{SELinux Policy Editorコントロールパネル}\label{fig:controlpanel}
\includegraphics*{images/controlpanel.png}
\end{figure}
アイコンをダブルクリック（またはクリックしてリターン押下)すると、対応し
た管理ツールが起動します。
それぞれのアイコンから設定できる設定内容は以下のようになります。
\begin{itemize}
 \item ステータス\\
       使い方は\ref{sec:seedit-status}節で。
       \begin{itemize}
	\item SELinuxのステータスを確認。SELinuxのモード、アプリケー
	      ションに割り当てられたドメインを確認できます。
	\item SELinuxのモードを変更
       \end{itemize}
 \item ドメインを管理
       \begin{itemize}
	\item 新規ドメインを作成(\ref{sec:createdomainGUI}節)
	\item ドメインの削除、無効化(\ref{sec:unconfine:gui}節)
       \end{itemize}
 \item ポリシーを生成(\ref{sec:addpolicy}節)
       \begin{itemize}
	\item SELinuxのアクセスログからポリシーを生成
       \end{itemize}
 \item ポリシーを編集(section \ref{sec:guieditor})
       \begin{itemize}
	\item テキストベースのエディタからポリシーを編集。
       \end{itemize}
 \item ポリシーのロード、ラベル付け
       \begin{itemize}
	\item　手動でポリシーをロード\\
	      GUIツールの中では、必要な時に自動的にポリシーはロードされ
	     ますが、手作業で行うこともできます。
	\item 全ファイルのラベルを初期化\\
	\item restoreconコマンドを実行\\
       \end{itemize}
\end{itemize}



\section{システムの状況を把握する}
seeditをインストールすることで、システムに何が起こっているのかを把握しま
しょう。
\subsection{Simplified policyはどこに?}
Simplified policyは、/etc/seedit/policy以下に「.sp」という拡張子のファイ
ルとしてインストールされています（詳細は後ほど）。Simplified policyは、
seedit-loadコマンド（内部的にseedit-converterコマンドが実際の作業を行っ
ています）によって、SELinuxのポリシー(SELinuxのバイナリポリシ、
file\_contextsファイル)に変換されます。変換後のポリシーは
/etc/selinux/seedit/policy, /etc/selinux/seedit/contexts/filesにインストー
ルされます。これらがカーネルに読み込まれていますが、/etc/selinux/seedit
以下のファイルを気にする必要は通常ありません。

\subsection{デフォルトで用意されているSimplified Policy}
デフォルトでインストールされているSimplified Policyは、「targetedポリシー」
相当のもので、設定が甘いです。具体的に以下のようになってます。
\begin{itemize}
 \item 選択されたデーモンプロセスだけが守られており、SELinuxによって制限
       されないプロセスの存在を許容\\
       「SELinuxによって制限されていないプロセス」には、「全てのアクセス
       を許可」するドメインが割り当てられます。アクセス制御は、普通の
       Linuxのパーミッションチェックのみになります。
 \item RBAC(Role Base Access Control)は設定されていない
\end{itemize}
SPDLは、原理的にはRBACも設定可能ですし、strictポリシー相当のものも記述可
能です。RBACについては、「RBACガイド」を参照してください。

\subsection{unconfinedドメイン}
  このように、デフォルトでは、SELinuxで制限されていないプロセスが存在します。
これらのプロセスには、「SELinuxによって制限されないドメイン(以下
unconfinedドメインと呼びます)」が割り当てられています。
unconfinedドメインは、全てのアクセスを許可するように設定されています。
unconfinedドメインが割り当てられたアプリケー
ションは、SELinuxによるアクセス制御を事実上受けなくなり、普通のLinuxの上
で動いているのと同様になります。\\
例えば、システム起動スクリプトには、initrc\_tドメインというunconfinedド
メインが割り当てられています。\\
どのプロセスにunconfinedドメインが割り当てられているのかを把握することがセキュリ
ティ上重要になってきます。

\subsection{システムの状況把握(GUI)}\label{sec:seedit-status}
システムの状況を把握するために、 {\i ステータス} をコントロールパネルか
ら選択します。{\it seedit ステータスビューア} というウィンドウが開きます。


\subsubsection{モードの確認と切り替え}\label{sec:mode}
 {\it SELinux} タブから、SELinuxのモードを確認したり切り替えたりできます
 (図 \ref{fig:status-selinux})。

\begin{figure}[h]
\caption{SELinuxのモードの確認と切り替え}\label{fig:status-selinux}
\includegraphics{images/status-selinux.png}
\end{figure}

{\it seeditがインストールされている？ はい}, という表示は、seeditが無事
にインストールされていることを示しています。\\
{\it 現在のモード}より、現在のモードがpermissiveモードであることが分か
ります。現在のモードの変更も、ここで行えます。
例えば、Enforcingモードに変えるには、 {\it Enforcingモード}を選択し、 {\it 適用} ボタンを押します。\\
{\it ブート時のモード} は、システム起動時のモードです。 {\it Permissive
モード}と表示されている時は、再起動時、システムがPermissiveモードで起動
します。実運用時には、両方ともEnforcingモードに切り替えるべきです。


\subsubsection{動作中のプロセスのドメインを確認}
プロセスタブ$\rightarrow$動作中のプロセス, より、動作中のプロセスのドメ
インを確認できます。
図は \ref{fig:status-working}実行例です。

\begin{figure}
\caption{動作中のプロセスのドメインを確認}\label{fig:status-working}
\includegraphics*{images/status-working.png}
\end{figure}
Unconfinedドメインで動作しているプロセスには「Unconfined」と表示されてい
ます。例えば、bashはUnconfinedドメインで動作しています。一方、httpdには、
httpd\_tドメインという通常のドメインが付与されていることが分かります。\\
PID, プロセス, ドメイン、をクリックすることで、それぞれの項目で結果をソー
トすることができます。\\
{\it 更新} ボタンを押すと、表示が更新されます。

\subsubsection{ネットワークプロセスのドメインを確認}

ネットワークプロセス(ネットワーク接続を外部から受け付けるプロセス)は、攻撃者が侵入する際の入口として使われます。ここを
しっかりと守ることが、外部からの不正侵入による被害を無くすために重要になります。
以下のような状況が理想です。
\begin{itemize}
 \item 全てのネットワークプロセスに適切なドメインが割り当てられている
 \item Unconfinedドメインが割り当てられた（SELinuxによって制限されない)プロセスがある場合\\
       以下のような選択肢があります。
\begin{itemize}
 \item 適切なドメインを割り当てる設定をする\\
       設定方法は、後ほど紹介します。
 \item SELinux以外の対策を強化する\\
       ファイアウォール(iptables)によって、接続できるアドレスを制限した
       り、パッチ当ての優先度を上げるなどする
 \item そのようなプロセスを立ち上げない（サービスを止める)
 \item リスクを許容する
\end{itemize}
\end{itemize}

ネットワークプロセスのドメ
 インは、プロセス$\rightarrow$ネットワークプロセスより確認できます。
実行例を図 \ref{fig:status-network}に示します。
\begin{figure}[h]
\caption{ネットワークプロセスのドメインを確認}\label{fig:status-network}
\includegraphics*{images/status-network.png}
\end{figure}
avahi-daemon, rpc.statdなどにUnconfinedドメインが割り当てられていること
が分かります。これらのサービスは使わないならば、停止すべきでしょう。使う
ならば、ドメインを割り当てるべきです。

\subsection{システムの状況把握(seedit-unconfinedコマンド)}
seedit-unconfinedコマンドは、rootユーザーになってから使います。
\subsubsection{動作中のプロセスのポリシー適用状況を確認}

「seedit-unconfined -e」にて、動作中のプロセスのポリシー適用状況を確認で
きます。以下に実行例を示します。
\begin{verbatim}
$ su -
# seedit-unconfined -e
Current SELinux mode: permissive ----(1)
PID     Comm    Domain
1       init    Unconfined(init_t) ---(2)
...
1853    sshd    Confined by sshd_t ---(3)
\end{verbatim}
\begin{itemize}
 \item (1) は、現在のSELinuxのモードを示しています。「permissiveモードである」
と言っています。permissiveモードでは、SELinuxのアクセス制限がかからない
ことに今一度注意しましょう。
 \item (2)は、initプロセスは、SELinuxに制限されていないことを言っていま
       す。そして、SELinuxに制限されていないドメインinit\_tが割り当てら
       れています(init\_tドメインは、全てのアクセスが許可されていること
       を意味します。)。
 \item  (3)は、sshdに、「sshd\_tドメイン」が割り当てられているとい
       う意味です。sshd\_tドメインは、sshdに必要最小限のアクセス許可を与
       えるように設定されています(設定内容は後で示す方法で確認できます)。
\end{itemize}
  ちなみに、ps -eZコマンドでも、動作中のプロセスのドメインを確認可能です。
  しかし、どのドメインがunconfinedドメインかを知ること
  はできません。SELinuxの制限がかかってないドメイン一覧は、
  /etc/selinux/seedit/policy/unconfined\_domainsに記述されていますので、
  このファイルの内容と照合する必要があります。

\subsubsection{ネットワークプロセスのドメインを確認}
ネットワークプロセス（外部からネットワーク接続を待ち受けているプロセス）
の状況をseedit-unconfined -nコマンドで確認できます（AppArmorの
unconfined`コマンドみたいなものです）。

さて、実際に確認してみましょう。seedit-unconfined -nの実行例を以下に示し
ます。
\begin{verbatim}
#seedit-unconfined -n 
Current SELinux mode: permissive ----(1)
/usr/sbin/smbd  Unconfined(initrc_t) -- (2)
/usr/sbin/sendmail.sendmail     Confined by sendmail_t --(3)
...	
\end{verbatim}
ネットワークプロセス一覧が表示され、ドメインの適用状況が表示されます
\begin{itemize}
 \item  (1)は現在のSELinuxのモードです。
 \item (2)は、smbd は制限されていないことを言っています。
 \item sendmailは、sendmail\_tドメインが割り当てられており、sendmail\_t
	は、最小限の権限を持つよう設定されてます。
\end{itemize}
この場合、smbdに対して何らかの対処をしないとセキュリティを保てません。

\subsubsection{Enforcing/Permissiveモードを切り換える}\label{sec:mode2}
インストール直後は、permissiveモードですが、以下のコマンドでEnforcingモードに切り換え可能です。
\begin{verbatim}
# setenforce 1
# getenforce 
enforcing
\end{verbatim}
ただし、これだと再起動時にまたPermissiveモードに戻ってしまいます。
ブート時からEnforcingモードにするには、/etc/selinux/configを次のようにします。
実運用の際には、このようにEnforcingモードにすることを強く薦めます。

\begin{verbatim}
SELinux=permissive
-->
SELINUX=enforcing
\end{verbatim}

\section{次に何をすればいいの？}
さて、SELinuxのステータスを把握したところで、次に何をすればいいのでしょ
う。以下のようにまとめることができます。
\begin{enumerate}
 \item アプリケーションのSELinux保護を無効に\\
       アプリケーションが、SELinuxのアクセス拒否のため動作しなかった場合、
       もっとも簡単な解決方法は、そのアプリケーションに対してのみ、
       SELinuxのアクセス制御が働かないようにすることです。
       セキュリティはもちろん落ちますが、SELinux全部を無効にするよりはマ
       シといえます。 \ref{sec:unconfine}で紹介します。       
 \item ポリシーを修正する\\
       アプリケーションが、SELinuxのアクセス拒否のため動作しなかった場合、
       本来は、ポリシーを編集すべきです。 \ref{sec:addpolicy}で紹介します。
 \item ドメインを新たに設定する\\
       SELinuxによって動作が制限されていないアプリケーションの安全性を高
       めるには、自分でドメインを設定し、アプリケーションにドメインを割
       り当てる必要があります。 \ref{sec:createdomainGUI}で紹介します。
\end{enumerate}

\section{アプリケーションに対するSELinux保護を無効に}\label{sec:unconfine}
アプリケーションに対するSELinux保護を無効にする方法は２つあります。
booleanパラメータを使う方法と、ポリシーファイルを移動する方法です。
ここで「アプリケーションに対するSELinux保護を無効にする」と言っています
が、
前述のunconfinedドメインを割り当てることにより、SELinuxのアクセス制御が
全部許可されるようにする、という意味です。
GUIおよびコマンドから作業することができます。

\subsection{GUI(ドメイン管理ツール)}\label{sec:unconfine:gui}
GUIから作業するには、 コントロールパネルから{\it ドメインを管理}を選択し
ます。\\
 {\it seedit
ドメイン・ロール管理}というウィンドウが開きます。 {\it ドメインを削除}タ
ブを選択します。

\begin{figure}
\caption{Unconfine application}\label{fig:manage-delete}
\includegraphics*{images/manage-delete.png}
\end{figure}

\subsubsection{方法１：一時的に無効に}
アプリケーションのSELinux保護を無効にする最も簡単な方法は、以下のステッ
プでドメインを一時的に無効にすることです。
\begin{enumerate}
 \item 無効にしたいドメインを選択
 \item {\it 一時的に無効} ラジオボタンを選択
 \item {\it 適用}　ボタンを押す
\end{enumerate}
 Apache Webサーバにunconfineドメインを割り当てたい場合を見てみま
す。
Apacheにはhttpd\_tドメインが割り当てられていますので、 httpd\_tを
選択し、 適用ボタンを押します。
Apacheを再起動し、 {\it ステータス} GUIから確認すると、ドメインとして{\it
Unconfined(initrc\_t)} が表示されます。\\
もう一度動作を制限するには、 {\it 一時的に無効にされたドメインを有効にす
る}からドメインを選択し、 {\it　適用} ボタンを押します。\\
ちなみに、これらの操作は内部的にはSELinuxのbooleanを使っています。詳細を
知りたい人はコマンドラインから操作してみるといいでしょう。


\subsubsection{方法2：ドメインを削除}
アプリケーションのSELinux保護を無効にするもう一つの方法は、次の手順のよ
うにドメインの設
定ファイルを除去することです。
\begin{enumerate}
 \item 無効にしたいドメインを選択
 \item  {\it 完全に削除} を選択
 \item 適用ボタンを押す
\end{enumerate}
しかし、元に戻したい場合は、手作業でやらなくてはなりません。
\begin{enumerate}
 \item cd /etc/seedit/policy
 \item mv /etc/seedit/policy/extras/{\it ドメインの名前}.sp
       /etc/seedit/policy/{\it ドメインの名前}.sp
 \item seedit-load
\end{enumerate}
この方法の良い点は，変換後のSELinuxのポリシーのサイズが小さくなることぐ
らいです。

\subsection{コマンドライン}

\subsubsection{方法１：booleanパラメータを使う}
SELinuxのbooleanパラメータ(条件変数とも呼ばれます)を知っているのならば、
簡単にできます。
例えば、Apacheの場合、
httpd\_tドメインが割り当てられていますので、
httpd\_disable\_transをonにして、Apacheを再起動するだけです。
再起動するのは、ドメインの割り当ては実行ファイルの実行のタイミングで起こ
るためです。httpd\_tドメインというドメインが割り当てられてるのを、
unconfinedなドメイン（この場合initrc\_t)を割り当てるようになります。割り
当てたいドメイン名が変わるので、Apacheを再起動する必要があります。

\begin{verbatim}
実行例:
# setsebool -P httpd_disable_trans 1
# /etc/init.d/httpd restart
# seedit-unconfined -e
Current SELinux mode: enforcing
PID     Comm    Domain
1111     httpd    Unconfined(initrc_t)
\end{verbatim}
元に戻したいときは、booleanをoffにします。
\begin{verbatim}
Example: 
# setsebool -P httpd_disable_trans 0
# /etc/init.d/httpd restart
# seedit-unconfined -e
Current SELinux mode: enforcing
PID     Comm    Domain
1111     httpd   Confined by httpd_t domain
\end{verbatim}
\subsubsection{方法２：ポリシーファイルを移動する}
ドメインが設定されているファイルは、
/etc/seedit/policy/{\it ドメイン名}.sp.
というファイルです。/etc/seedit/policyディレクトリ以外にある設定は無効に
なります。この振舞を利用し、ファイルを別のディレクトリに移動して、設定を反映
し直し、アプリを再起動すればOKです。
\begin{verbatim}
実行例: 
ApacheのSELinux保護を無効に
# cd /etc/seedit/policy
# mkdir unused
# mv httpd_t.sp unused
# seedit-load
# /etc/init.d/httpd restart
# seedit-unconfined -e
Current SELinux mode: enforcing
PID     Comm    Domain
1111     httpd    Unconfined(initrc_t)
\end{verbatim}
元に戻したい場合は、/etc/seedit/policyディレクトリに再度移動し、設定を反
映します。
\begin{verbatim}
Example: 
# cd /etc/seedit/policy
# mv unused/httpd_t.sp .
# seedit-load
# /etc/init.d/httpd restart
# seedit-unconfined -e
...
\end{verbatim}
\section{Simplified Policyの基礎知識}\label{sec:policy}
Simplified Policyを扱う前に、基本的な知識をおさえておきましょう。

\subsection{どこに？}
Simplified Policyは、/etc/seedit/policyディレクトリに配置されています。
このディレクトリの下には、 {\it ドメイン名}.spというファイルが配置されて
います。
\subsection{書式概要}
 Simplified Policyは、Simplified Policy Description Language(SPDL)という
 書式で書かれています。詳細は、別のドキュメント(Specification of SPDL)に
 書かれていますが、全てを理解する必要はありません。書式を知らなくとも、
 Simplified Policyを生成するツールがあるからです。\\
が、SPDLの概要を知っておくことは、どんな設定がされているのか知る上で重要
 です。ここでは、SPDLの概要を具体例と共に見ていきます。 具体例としては、
 図\ref{policyexample}のApache用ポリシを使います。

\begin{figure}
\caption{Simplified  Policyの例：Apache Webサーバのためのポリシ}\label{policyexample}
\begin{verbatim}
     1  {
     2  domain httpd_t;
     3  program /usr/sbin/httpd;
     4  include common-relaxed.sp;
     5  include daemon.sp;
     6  include nameservice.sp;
     7  allow /var/www/** r,s;
     8  allow /var/log/httpd/** r,a,s;
     9  allow /etc s;
    ...<snip>..
    10  allownet -protocol tcp -port 80,443 server;
    11  allowpriv netlink;
    12  }	
\end{verbatim}
\end{figure} 

\subsubsection{アプリケーションにドメインを付与する}
2行目と3行目は、アプリケーションにドメインを付与する設定です。
2行目は、ドメインの命名です。「httpd\_t」というドメインを命名しています。
以下、\{\}内に記述される設定は、httpd\_tドメインに対するものになります。
デフォルトでは、ドメインは何もアクセス権限を与えられません。明示的にドメ
インに権限を与える設定を記述していくことで、設定を行っていきます。\\
３行目は、実際にアプリケーションにドメインを付与する設定です。アプリケー
ションの実行ファイル(/usr/sbin/httpd)を指定し、ドメインを付与します。
これにより、/usr/sbin/httpdが実行されると同時にドメインhttpd\_tが割り当
てられるようになります。
\begin{itemize}
 \item 上級者向けメモ\\
       ドメインを付与するために、SELinuxのドメイン遷移が使われています。
       2行目と3行目では、unconfinedドメインが、/usr/sbin/httpdを実行する
       と、/usr/sbin/httpdにhttpd\_tドメインが割り当てられる、という設定
       がされます。SELinuxのポリシーの書式で書くと次のようになります。
\begin{verbatim}
domain_auto_trans(unconfined_domain, /usr/sbin/httpdのタイプ, httpd_t)
* unconfined_domainは、unconfinedドメインに付与される属性
\end{verbatim}
       unconfinedドメインじゃないドメインから
       /usr/sbin/httpdが実行された場合は、/usr/sbin/httpdにドメインが割
       り当てられないことに注意が必要です。
\end{itemize}
\subsubsection{典型的な設定を使いまわす:include文}
4,5,6行目で、一般的なアプリケーションで共通して使う設定を挿入して
います。include書式を使うと、他のファイルに記述された設定を挿入すること
ができます。実際に、どんな設定が挿入されるかは、/etc/seedit/policy/includeディ
レクトリ以下を見れば分かります。
例えば、 {\it include include/nameservice.sp;}
では、/etc/seedit/policy/include/nameservice.spに記述された設定が挿入さ
れます。/etc/hostsへの読み込み権限などが許可されます。

\subsubsection{ファイルへのアクセスを許可する:allow文}
7から10行目では、ファイルへのアクセスを許可しています。
allowという書式を使って、ファイル名とパーミッションが記述されています。
ファイル名については、次のような一括指定記法が使えます。
\begin{verbatim}
ディレクトリ名/* :ディレクトリ以下のファイル全て。サブディレクトリは含まない。
ディレクトリ名/**:  ディレクトリ以下のファイルをサブディレクトリも含め全て。
例えば、/etc/*とした場合は、/etc直下のファイルが指定され、
/etc/sysconfig/networkなど、サブディレクトリのファイルは含まれません。
/etc/**とすると、サブディレクトリにあるファイルも含まれます。
\end{verbatim}
\textasciitilde ~ から始まるファイル名は、ホームディレクトリ（/root以外）
を表します。
\begin{verbatim}
~/public_html/**
\end{verbatim}
は、各ユーザのホームディレクトリの下にあるpublic\_htmlディレクトリ以下の
ファイル全てを表します。\\

パーミッションとしては、以下のパーミッションを使うことができます。
\begin{itemize}
 \item 基本パーミッション
       \begin{itemize}
	\item s\\
	      Searchの略です。ファイルツリーをサーチする、という意図
	      で作られました。ディレクトリにあるファイル一覧を取得する権
	      限、および、カレントディレクトリに設定する権限が設定されま
	      す。ファイルに対してこのパーミッションを設定しても何も意味
	      はありません。	      
	\item  r\\
	      Readの略です。ファイルを読み込む権限が設定されます。
	\item x\\
	      Executeの略です。ファイルを実行する権限が設定されます。
	\item  w\\
	      Writeの略です。ファイルを上書き、追記する権限や、ファイル・
	      ディレクトリを生成消去する権限が設定されます。
       \end{itemize}
 \item 詳細設定パーミッション\\
       wパーミッションは、多くの権限が設定されます。本当に必要最小限の権
       限を設定するために、wを分割した５つのパーミッションを利用できます。
       \begin{itemize}
	\item a\\
	      Appendの略です。ファイルを追記オープンする権限が設定されま
	      す。
	\item o\\
	      Overwriteの略です。ファイルを上書き保存する権限が設定され
	      ます。
	\item c\\
	      Createの略です。ファイルやディレクトリを新規作成する権限が
	      設定されます。
	\item e\\
	      Eraseの略です。ファイルやディレクトリを消去する権限が設定
	      されます。
	\item t\\
	      Setattrの略です。ファイルやディレクトリの属性を変更する権
	      限が設定されます。属性とは、ファイルの所有者,最終更新時刻など，ファイルに関
	      する情報のことです。ファイルのセキュリティ属性(SELinuxのラ
	      ベル)の変更は許可されません。
       \end{itemize}       
\end{itemize}
さて、これで、7-9行目の設定の意味が理解できます。
\begin{itemize}
 \item 7行目: http\_tドメインが、/var/www以下のファイル一覧取得可能、ファ
       イル(サブ
       ディレクトリにあるファイル含む)の読み込みを可能です
 \item 8行目:
       http\_tは、/var/log/httpd以下(サブディレクトリ含む)のファイル一覧取得可能、およびファイルを読み込み，追記可能です。
 \item 9行目
       httpd\_tは、/etcにあるファイル一覧のみを取得可能です。/etc以下の
       ファイルに対しては何もできません。
       /etc以下のファイルにアクセスさせたい場合は、例えば、/etc/*や
       /etc/**などと記述する必要があります。
\end{itemize}

\subsubsection{ネットワークアクセス制御を設定:allownet}
ネットワークに関連するアクセス制御も可能です。
ポート番号を使ってサーバーとして振る舞う権限、クライアントとしてポートに
接続する権限を設定可能です{\footnote ネットワークインターフェースやIPア
ドレスの利用制御も可能ですが、これ
らはcommon-relaxed.spでデフォルト許可されています}。
10行目では、httpd\_tドメインがTCP80,443ポートを使ってサーバーとして振る
舞う権限をあたえられています。
もし、MySQLサーバー(TCP 3306)に接続したいなら、以下のように設定します。
allownet -protocol tcp -port 3306 client;\\
ポート番号の指定としては、 -1023, 1024-, * という表記が可能です。
 -1023は全てのWellknownポートです。1024-は、1024以上のポート番号、*は全
 てのポート番号を意味します。

\subsubsection{他の特権を設定する:allowpriv}
ファイルやネットワークに関連しない操作も、SELinuxによって制限されていま
す。
{\it allowpriv 特権名;}.という書式で、設定できます。
例えば、11行目では、netlinkソケット(カーネルと通信するために使われる)の
利用許可を与えてます。

\subsubsection{Unconfinedドメインにする}
allowpriv all;と設定することで、そのドメインがunconfinedドメインになりま
す。
\begin{verbatim}
{
domain httpd_t;
program /usr/sbin/httpd;
allowpriv all;
}
\end{verbatim}
このようにすると、httpd\_tは、unconfinedドメインとして扱われます。\\
/etc/selinux/seedit/policy/unconfined\_domains にも、httpd\_tが追加されて
ます。

\subsection{GUIエディタ}\label{sec:guieditor}
コントロールパネルから {\it ポリシーを編集} を選択すると、エディタが開き
ます。
 {\it 開く} を選択し、ドメインを選択します。
例えば、httpd\_t ドメインを選択すると、図\ref{fig:edit}のような画面にな
ります。テキストエディタのように、ポリシーを編集できます。\\
 {\it 保存} ボタンを押すと、編集内容を保存し、設定を反映します。\\
{\it Reload }ボタンを押すと、再度ファイルからの設定内容を読み出します。
これは、他のツール（ポリシ生成ツール等）で、設定内容が変更された場合に便
利です。\\
{\it 追加} ボタンを押すと、ポリシーを挿入するためのウィンドウが開きます
(図\ref{fig:edit-file}, \ref{fig:edit-network})。
{\it ファイル} タブから、ファイルアクセス制御設定を挿入できます。図
\ref{fig:edit-file}の例では、  {\it 追加}ボタンを押すと、
\begin{verbatim}
allow /var/www/** r,s;
\end{verbatim}
という設定が末尾に追加されます。\\
{\it ネットワーク}タブからは、ネットワークに関する設定を挿入できます。図
\ref{fig:edit-network}では、  {\it 追加}ボタンを押すと
\begin{verbatim}
allownet -protocol tcp -port 80 server;
\end{verbatim}
が挿入されます。


\section{ポリシーを追加する}\label{sec:addpolicy}
\subsection{Permissiveモードで問題切り分け}
SELinuxのアクセス拒否のためにアプリケーションが動作しない、と判明したら
ポリシーを追加する必要があります。\\
ポリシーを追加する前に、permissiveモードで動作確認を行います。
もし、permissiveモードでアプリケーションが動作したならば、SELinuxが原因
でアプリケーションが動作しないことになります。この場合は、ポリシーを追加
してやる必要があります。
SELinux Policy Editorでは、
このような場合にポリシーを生成するためのツールがGUIおよびコマンドライン
で用意されています。より具体的な例は、新規ドメイン作成とともに、
\ref{sec:createdomain}章にて紹介します。

\subsection{ポリシ生成の仕組み}
 ポリシの生成はSELinuxのログを基にして行われます。 Permissiveモードでの
 動作確認の間に, SELinuxのログが取得されます。Permissiveモードとは、アク
 セスがSELinuxによって拒否される場合、ログを取るだけのモードでした。
 (SELinuxが原因で動作しない)アプリケーションを動作させるには、
 拒否されるアクセスを許可してやる必要があります。\\
 以下は、アクセス拒否ログの例です。このログを例に、ポリシ生成ツールがど
 うやってポリシを生成するのかを見ていきます。
\begin{verbatim}
----
time->Wed Apr 26 18:34:32 2006
1: type=PATH msg=audit(1146090872.442:29): item=0 
name="/etc/vsftpd/vsftpd.conf" flags=101  inode=584775 dev=03:03 
mode=0100600 ouid=0 ogid=0 rdev=00:00
type=CWD msg=audit(1146090872.442:29):  
cwd="/etc/selinux/seedit/src/policy/simplified_policy"
2: type=SYSCALL msg=audit(1146090872.442:29): arch=40000003 
syscall=5 success=yes exit=3 a0=bfb04c52 a1=8800 a2=0 a3=8800 
items=1 pid=13151 auid=4294967295 uid=0 gid=0 euid=0 suid=0 
fsuid=0 egid=0 sgid=0 fsgid=0 comm="vsftpd" exe="/usr/sbin/vsftpd"
3: type=AVC msg=audit(1146090872.442:29): avc:  denied  { read } 
for  pid=13151 comm="vsftpd" name="vsftpd.conf" dev=hda3 
ino=584775 scontext=user_u:system_r:ftpd_t 
tcontext=system_u:object_r:default_t tclass=file
----	
\end{verbatim}
３行目はSELinuxのアクセス拒否ログで， 「  ftpd\_tドメインが、
vsftpd.confという名前のファイルを読もうとして拒否された」 という意味です.
３行目から、以下のような設定を追加する必要があることが分かります。

\begin{verbatim}
allow vsftpd.conf r;
\end{verbatim}
これだけでは、vsftpd.confのフルパスを記述してないので、アクセス
を許可できてません。しかし、３行目のログにはフルパス情報は書かれていませ
ん。 フルパスを得るために、1行目のログを利用します。ここに、vsftpd.conf
のフルパスは/etc/vsftpd/vsftpd.confと書かれています。
1行目と３行目を組み合わせることで、以下を追加すればいいことが分かります。
\begin{verbatim}
allow /etc/vsftpd/vsftpd.conf r;	
\end{verbatim}
auditdサービスを起動していない場合、1行目のログは取得されません。つまり、
フルパス情報がログに含まれないことを意味します。ですので、SELinux Policy
Editorを使うときはauditdを使うことをお薦めします。\\
 なお、auditdが動いてない場合は、locateコマンドを使ってフルパスを推測し
 ますが、失敗することも多いです。

\subsection{GUI(ポリシ生成ツール)}

\subsubsection{ツールを起動}

コントロールパネルより {\it ポリシーを生成}をクリックします。図
\ref{fig:vsftpd-generate-1}のような画面が開きます。

\begin{figure}
\caption{ポリシ生成ツール}\label{fig:vsftpd-generate-1}
\includegraphics*{images/vsftpd-generate.png}
\end{figure}

これは、ポリシ自動生成のための設定画面です。通常はデフォルトのままでかま
いません。「ポリシーの生成」ボタンを押すことで、ポリシーが生成されます。\\
なお、ここで設定可能な項目を参考のために解説します。\\
\begin{itemize}
 \item 入力\\
       これは、SELinuxのアクセスログが記録される場所を設定します。auditd
       が動いている時は、audit.logを選びます。そうでない場合は、dmesgを
       選択します。自分でファイル名を指定することもできます。
 \item セキュリティの高い設定を生成\\
       これがチェックされると、ポリシ生成ツールは、よりセキュリティの高
       い設定を生成しようとします。現バージョンでは、詳細書き込みパーミッ
       ション(a,o,c,e,t)を使う設定を生成します。これをチェックしない場合
       は、wパーミッションしか使いません。

 \item 全てのログを読み込み\\
       これをチェックすると、選択したログから全てのメッセージを入力とし
       て読み込みます。
       これをチェックしない場合は、最後の設定反映後(load\_policyが許可さ
       れた後)のログのみを読み込み
       ます。
 \item Skip search log\\
       これをチェックすると，dir:searchパーミッションのアクセス拒否ログ
       をスキップします。このパーミッションは余計な設定生成につながりや
       すいからです。
\end{itemize}


\subsubsection{結果を確認し、設定を実際に追加}
{\it 設定を生成}　ボタンを押すと、ポリシーが生成されます。　しばらく時間
がかかります。設定生成が完了すると、「結果」タブに結果が表示されます。\\
図 \ref{fig:vsftpd-generate-result-1}は、生成された結果の例です。

\begin{figure}
\caption{ポリシ生成結果}\label{fig:vsftpd-generate-result-1}
\includegraphics*{images/vsftpd-generate-result.png}
\end{figure}
最初の行では、 {\it allownet -protocol tcp -port
1024- server;} という設定をvsftpd\_tドメインに追加するかを聞いています。
対応するアクセス拒否ログも一緒に表示されています。このポリシーを追加した
い場合は、チェックボックスにチェックを入れます。\\


{\it まとめて指定} ボタンは便利な機能です。ディレクトリ単位でまとめてア
クセス許可をすることができます。\\
 {\it allow /etc/vsftpd/vsftpd.conf r,s;}を選択し、「まとめて指定」ボタ
 ンを押していくと、以下のようにファイル名が変わっていきます。
\begin{verbatim}
/etc/vsftpd/vsftpd.conf ->
/etc/vsftpd/* ->
/etc/vsftpd/** ->
/etc/* ->
/etc/** ->
/* ->
/** ->
\end{verbatim}
{\it まとめて指定を戻す}ボタンを押すと、上と逆の順番でファイル名が変わっ
ていきます。\\
チェックされたポリシーは、 {\it 以下の設定が保存されます}の部分に表示さ
れます(図\ref{fig:vsftpd-generate-save-1})。
設定を追加する前に、権限を与えすぎでないか今一度見直します。大丈夫そうな
らば、 {\it セーブし、設定を適用}ボタンを押します。
これらのポリシーがファイルに記述されるだけでなく、設定内容もSELinux側に
反映されます。

\begin{figure}
\caption{保存する前の画面}\label{fig:vsftpd-generate-save-1}
\includegraphics*{images/vsftpd-generate-save.png}
\end{figure}





\subsection{コマンドライン(audit2spdlコマンド)}
audit2spdlというコマンドを使うことでも、ポリシー生成を行うことができます。
使いかたは、以下のようになります。
auditdサービスが起動していない場合(Fedora Core5のデフォルト),
\begin{verbatim}
# audit2spdl -dl
\end{verbatim}
When auditd is running(Fedora Core4 default)
\begin{verbatim}
# audit2spdl -al
\end{verbatim}
You can read log by specifying filename, 
\begin{verbatim}
# audit2spdl -l -i /var/log/messages 
\end{verbatim}

audit2spdlコマンドは、SELinuxのアクセス拒否ログを、Simplified Policyに変
換するものです。これにより、アプリケーションを動作させるために必要な権限
を簡単に追加できます。以下が、出力例です。

\begin{verbatim}
#audit2spdl -dl
.... It takes some time...
-------------------------
#SELinux deny log:
audit(1146162965.963:16): avc:  denied  { read } for  pid=6653 
comm="vsftpd" name="vsftpd.conf" dev=hda3 ino=584775 
scontext=user_u:system_r:ftpd_t 
tcontext=system_u:object_r:default_t tclass=file
#Suggested configuration
File ftpd_t.sp:
allow /etc/vsftpd/vsftpd.conf  r;
-------------------------
...
\end{verbatim}
これは、vsftpd.confにreadアクセス拒否をされたログが出ていますが、このア
クセスを許可するには、
\begin{verbatim}
allow /etc/vsftpd/vsftpd.conf  r;	
\end{verbatim}
という設定をftpd\_t.spファイルに追加する必要がある、と言っています。

\subsubsection{audit2spdlを効率よく使うために}
auditdサービスを有効にしておいたほうが、効率よく作業ができます。
auditdサービスはより詳細なログを取ってくれるからです。
SELinuxのアクセス拒否ログには、フルパス情報が含まれていません。
例えば/etc/vsftpd.confにアクセス拒否された場合、「vsftpd.conf」にアク
セス拒否されたとしか記録されません。
auditdサービスを使うと、フルパスも記録されます。
アクセス拒否ログから、ポリシーを生成するには，フルパス情報が不可欠です。
auditdサービスを有効にすることで、フルパス情報を得られ、正しいポリシーが
生成できるわけです。\\
Fedora Core5の場合、以下でauditdを有効にできます。
\begin{verbatim}
#yum install audit
#chkconfig auditd on
#/etc/init.d/auditd start
\end{verbatim}
auditdを有効にしたら、通常は「audit2spdl -al」で事足ります。audit2spdl
-dlは意味がなくなるので注意が必要です。\\
auditdを使わない場合、audit2spdlは、フルパス情報を「locateコマンド」と組
み合わせて推測します。ただし、locateコマンドを使う前に定期的に「updatedb」
コマンドを走らせる必要があります（デフォルトではcronジョブで走っていま
す）。


\subsubsection{提示されたポリシーを追加して設定反映}
上の例では、必要なポリシーが提示されただけで、設定が反映されていません。
/etc/seedit/policy/vsftpd.sp.を開き、
「allow /etc/vsftpd/vsftpd.conf  r;」という行を${}$の間に記述します。次
のようになります。
\begin{verbatim}
{
domain vsftpd\_t
program /usr/sbin/program;
allow ....
<ここに追加！>
}
\end{verbatim}
ポリシーを追加したら、その変更内容を反映する必要があります。
「seedit-load」とタイプします。
\begin{verbatim}
#seedit-load
seedit-load: Success
\end{verbatim}
このコマンドは、Simplified PolicyをSELinuxのポリシの形式に変換し、
/etc/selinux/seedit以下に生成されたポリシーをインストールします。
そして、そのポリシーをカーネルに読み込ませ、必要次第でファイルのラベル付
けもします。\\
seedit-loadコマンドの詳細な進行具合を「-v」オプションを付与することで見
ることができます。
\begin{verbatim}
# seedit-load -v
mkdir -p ./sepolicy;
m4 -s ./simplified_policy/*.sp >./simplified_policy/all.sp;
/usr/bin/seedit-converter -i ./simplified_policy/all.sp -o 
./sepolicy -b ./base_policy -I ./simplified_policy/include ;
.................

cp /etc/selinux/seedit/contexts/files/file_contexts.all 
/etc/selinux/seedit/contexts/files/file_contexts.all.old
seedit-load: Success	
\end{verbatim}

なお、上の例では、
\begin{verbatim}
allow /etc/vsftpd/* r;.	
\end{verbatim}
という設定を追加してもよいです。これは、ファイル名が、audit2spdlに提示さ
れたものとは異なります。が、システム管理者は、/etc/vsftpdディレクトリが
vsftpdの設定ファイルであることを知っていますので、このディレクトリ全体の
読み込み権限を与えてしまったほうが効率がよいです。

\subsubsection{audit2spdlについての諸注意}
\begin{enumerate}
 \item セキュリティ上最適とは限らない\\
audit2spdlによって提示される設定は、最適なものとは限りません。
提示された設定を追加する前に、注意深く見直す必要があります。
例えば、audit2spdlのデフォルトは、詳細設定パーミッション(o,a,c,e,t))を提示しません。
代わりにwを提示しますので、設定が粗くなります。ちなみに、詳細設定パーミッ
       ションを提示するには、sオプションを例えばaudit2spdl -alsのように
       使います。

\item 設定の提示に失敗することがある\\
 ログからファイルのフルパスを得ることを失敗すると、以下のようなメッセー
       ジが現れます。
\begin{verbatim}
#Failed to generate, because failed to obtain fullpath.	
\end{verbatim} 
SELinuxのログにはフルパス情報は含まれてませんが、audit2spdlはフルパスを
       得るため様々な作業を行っています。それにも関らず失敗することもあ
       ります。auditdサービスを起動しておくことで、フルパスを得る可能性
       を高めることができます。


\end{enumerate}


%%%!!!!注意、提示された設定をむやみやたらに追加しない

\section{新たにドメインを作成する}\label{sec:createdomain}
seeditでのポリシーの書き方を覚える最も良い方法は、新たなドメインを作成す
る設定を試すことです。vsftp FTPサーバにftpd\_tドメインを付与する実例を元
に、見ていきましょう。\\
新たなドメインを作成、設定する場合の手順は一般的に次のようになります。
\begin{enumerate}
 \item テンプレートとなる設定を作成
 \item ドメインが正しく付与されることを確認
 \item テスト動作とポリシーの追加
\end{enumerate}


\subsection{GUIから新規ドメインを設定}\label{sec:createdomainGUI}
vsftp\_t ドメインを作成し、Anonymous FTPサーバとして動作するのに必要な設
定をします。

\subsubsection{テンプレートを作成}
ドメイン管理GUIを使うことで、新規ドメインを設定できます。コントロールパ
ネルから、ドメインを管理を選択します。\\
vsftpdにvsftpd\_tドメインを割り当てます。
図\ref{fig:template}のように設定します。\\
まず、実行ファイルの名前を指定します。「/usr/sbin/vsftpd」を入力します。
\\
ドメイン名として、「vsftpd\_t」を入力します。\\
あとは、いくつかの質問に答えます。デーモン用のドメインを作成するには、
「デーモンプログラムですか？」の「はい」を忘れないようにします。\\

{\it　テンプレートを作成}ボタンを押すと、{\it 作成されたテンプレート}に
設定が生成されます。\\


\begin{figure}
\caption{新規ドメイン作成画面}\label{fig:template}
\includegraphics*{images/template.png}
\end{figure}

\subsubsection{アクセスすると分かっている設定を追加} 
 アプリケーションについての知識がある場合、あらかじめどんなアクセス権限
 が必要か分かっていることも多いです(分かってない場合は、後からポリシ生成
 ツールで追加できます)。その場合、この画面から追加可能です。\\
 
今回は、 Anonymous FTPサーバを構築しますので、公開ディレクトリ（/var/ftp
 以下）への読み込み権
 限が必要ですし、21番ポートを使う権限が必要です。\\
 これらの設定は「ポリシーを追加」ボタンを使って追加できます。
 図\ref{fig:add-file}では、/var/ftpディレクトリ以下への読み込みアクセス
 を設定してます。図\ref{fig:add-network}では,TCP21番ポートを使ってサーバー
 として振る舞うことを許可しています。{\it 追加} ボタンを押すと、
 \begin{verbatim}
allow  /var/ftp/** r,s;
allownet -protocol tcp -port 21 server;
 \end{verbatim}
 のような設定が追加されます。追加したい設定を全て追加したら、「セーブし、
 設定を適用」ボタンを押します。
 
\begin{figure}
 \caption{Insert file access control policy}\label{fig:add-file}
 \includegraphics*{images/add-file.png}
\end{figure}


\begin{figure}
\caption{Insert network access control policy}\label{fig:add-network}
\includegraphics*{images/add-network.png}
\end{figure}


%% chroot環境でのパス提示の注意

\subsubsection{ドメインの確認}
Permissiveモードに切り替え、vsftpdを起動し、そのドメインが「vsftpd\_t」
であることをステータスツールなどで確認します。

\subsubsection{テスト動作とポリシーの追加}
vsftpdをpermissiveモードでテスト動作させます。テスト動作を通じて、必要な権限を洗い出すため
です。

以下のコマンドでは, Anonymous ftpでファイル転送できることを確認してます。

\begin{verbatim}
#echo "test">/var/ftp/pub/test.txt
(テスト用のファイル作成)

$ ftp localhost
Name (localhost:ynakam): Anonymous
Password: <なんでもOK>
> cd /var/ftp/pub
> get test.txt
\end{verbatim}

ここで、ログを見てみると（auserch -m AVCで見ることが出来ます)、様々なア
クセスログが出ていることが分かります。ポリシー生成ツールでこれらを許可す
る設定を追加していきます。
 {\it ポリシーを生成} をコントロールパネルから選択すると、図
 \ref{fig:vsftpd-generate}のような画面が開きます。
通常は、デフォルトの設定のまま「ポリシーを生成」ボタンを押します。
図 \ref{fig:vsftpd-generate-result}のように結果画面が開きます。
追加したい設定についてはチェックボタンを押します。ディレクトリ丸ごとアク
セス許可をしたい場合は「まとめて指定」を使います。
今回の場合は、/etc/vsftpdディレクトリにまとめて設定を許可したほうが効率
がいいので、/etc/vsftpd/vsftpd.confのところで、「まとめて指定」ボタンを
使います。
ファイル名は、  /etc/vsftpd/vsftpd.conf  $\rightarrow$ /etc/vsftpd/*
$\rightarrow$ /etc/vsftpd/**のように変わっていきます\\

さて、今回の例では図 \ref{fig:vsftpd-generate-save}のような設定が追加さ
れることになります。 {\it セーブし設定を適用} を押して設定を反映します。\\
再度vsftpdの動作確認をして、ポリシ生成ツールを使います。何も設定が生成さ
れなくなったら、次はEnforcingモードでテストします。もし動作すれば、設定
はおしまいです。そうでなければ、生成ツールでポリシを追加し、再度テストし
ます。テスト、ポリシの生成をアプリケーションがEnforcingモードで動作する
まで繰り返します。


\begin{figure}
\caption{Policy Generate tool}\label{fig:vsftpd-generate}
\includegraphics*{images/vsftpd-generate.png}
\end{figure}

\begin{figure}
\caption{Policy Generate result}\label{fig:vsftpd-generate-result}
\includegraphics*{images/vsftpd-generate-result.png}
\end{figure}

\begin{figure}
\caption{Before save}\label{fig:vsftpd-generate-save}
\includegraphics*{images/vsftpd-generate-save.png}
\end{figure}

\subsection{コマンドラインからドメイン作成}
\subsubsection{テンプレートとなる設定を作成}
seedit-templateコマンドを使うことで、テンプレートとなる設定を作成できま
す。書式は以下です。
\begin{verbatim}
seedit-template -d <ドメインの名前> -e <実行ファイル名> -o <出力>
\end{verbatim}
今回は、ドメインの名前は「ftpd\_t」で、実行ファイルは「/usr/sbin/vsftpd」
ですので、
以下のように実行します。コマンドと実行結果を示します。
\begin{verbatim}
# seedit-template -d vsftpd_t -e /usr/sbin/vsftpd
{
domain ftpd_t;
program /usr/sbin/vsftpd;
include common-relaxed.sp;
include daemon.sp;
include nameservice.sp;
}
\end{verbatim}
テンプレートとなる設定が生成されています。/usr/sbin/vsftpdにftpd\_tを付
与しています。
 {\it include }から始まる行で、一般的なデーモンプログラムに必要な権限が
 与えられます。
この設定を、
/etc/seedit/policy/ftpd\_t.spに保存します。
ファイル名は、必ず「ドメイン名.sp」である必要があります。さもないと、設
定反映時にエラーが出ます。


\subsubsection{ドメインが正しく付与されることを確認}
設定の反映には、次のコマンドを使います。
\begin{verbatim}
#seedit-load
\end{verbatim}
なお「-v」をつけると詳細な経過を見ることができます。\\
また、permissiveモードに切り替える必要があります。
ftpd\_tにアクセス許可する設定をしていませんので、vsftpdが起動しようとし
てもenforcingモードではアクセス拒否のため失敗するからです。
\begin{verbatim}
#setenforce 0
#getenforce
Permissive
\end{verbatim}
vftpdを起動して、seedit-unconfinedコマンドでvsftpdのドメインを確認します。
\begin{verbatim}
# /etc/init.d/vsftpd restart
# seedit-unconfined -e
10530   vsftpd  Confined by ftpd_t
\end{verbatim}
上のようにvsftpdにftpd\_tドメインが付与されていることと思います。

\subsubsection{テスト動作とポリシーの追加}
 さて、次はpermissiveモードでアプリケーションをテスト動作させます。
そして、audit2spdlでどんな権限が足りないのかを洗い出します。
ここでは、vsftpdがAnonymous FTPサーバとして動作するのに必要な権限を洗い
出すことにします。\\
テストのために、以下のようにftpサーバにAnonymousとしてログインします。
\begin{verbatim}

# touch /var/ftp/pub/test.txt
↑　テスト用のファイルを作成
$ ftp localhost
Name (localhost:ynakam): Anonymous
Password: <anything is OK>
#以下、pub/test.txtをダウンロードしている
ftp> ls
ftp > cd pub
ftp > get test.txt
ftp > quit
\end{verbatim}

ログを閲覧します。
以下、auditdサービスが起動しているという前提で話を進めます。
auditdサービスが起動していない場合は、audit2spdl -alを-dlに置き換えて読
んでください。

\begin{verbatim}
#auserch -m AVC 
↑/var/log/audit/audit.logのログを閲覧するコマンドです。
\end{verbatim}
様々なアクセス拒否が出ていると思います。\\
audit2spdlを使ってみましょう。

\begin{verbatim}
#audit2spdl -al
-------------------------
#SELinux deny log:
audit(1146179470.043:86): avc:  denied  { search } for  
pid=10904 comm="vsftpd" name="vsftpd" dev=hda3 ino=584772 
scontext=user_u:system_r:ftpd_t 
tcontext=system_u:object_r:etc_t tclass=dir
#Suggested configuration
File ftpd_t.sp:
allow /etc/vsftpd  s;
-------------------------
-------------------------

#SELinux deny log:
type=AVC msg=audit(1148486747.277:30): avc:  denied  { append } for  pid=11761 comm="vsftpd" name="xferlog" dev=hda3 ino=163412 scontext=user_u:system_r:ftpd_t
tcontext=system_u:object_r:var_log_t tclass=file
#Suggested configuration
File ftpd_t.sp:
allow /var/log/xferlog  w,r,s;
-------------------------
.....
\end{verbatim}
様々な設定を追加しなければならないことが分かると思います。
なお、以下のように「\#」から始まる行が提示されることがあります。
\begin{verbatim}
-------------------------
#SELinux deny log:
type=AVC msg=audit(1148486754.718:36): avc:  denied  { lock } for  
pid=11763 comm="vsftpd" name="test.txt" dev=hda3 ino=163311 
scontext=user_u:system_r:ftpd_t tcontext=system_u:object_r:default_t
 tclass=file
#Suggested configuration
File ftpd_t.sp:
#Failed to generate, because failed to obtain fullpath.
#allow test.txt  r,s;
-------------------------
\end{verbatim}
これは、audit2spdlがtest.txtのフルパスを発見することに失敗したため、先頭
に\#がついています。しかし、test.txtのフルパスは、/var/ftp/pub/test.txtで
あることを読者は知っているので、
\begin{verbatim}
allow /var/ftp/pub/test.txt  r,s;	
\end{verbatim}
を追加すればいいことが分かります。
筆者の環境では、以下のような設定が提示されました。
\begin{verbatim}
allow /etc/vsftpd  s;
allow /var/log/xferlog  w,r,s;
allow /var/ftp/pub  s;
allow /var/ftp/pub/test.txt  r,s;
allownet -protocol tcp -port 21 server;
allow /etc/vsftpd/vsftpd.conf  r,s;
allowpriv cap_sys_chroot;
allow /var/ftp  s;
allow /var/log/xferlog  r,s;
\end{verbatim}
これをそのまま追加してもいいのですが、冗長な設定があります。
例えば、/var/ftp、/etc/vsftpdはディレクトリ全体を読み込み許可すれば冗長
な設定を削れます。冗長な設定を削ると、ftpd\_t.spは結局以下のようになりま
す。

\begin{verbatim}
{
domain ftpd_t;
program /usr/sbin/vsftpd;
include common-relaxed.sp;
include daemon.sp;
include nameservice.sp;
# added by audit2spdl suggestion
allow /etc/vsftpd/**  r,s;
allow /var/ftp/**  r,s;
allow /var/log/xferlog  r,w,s;
allownet -protocol tcp -port 21 server;
allowpriv cap_sys_chroot;
}
\end{verbatim}
さて、seedit-loadコマンドで設定を反映し、vsftpdを再起動して、再度動作テ
ストをしてみましょう。audit2spdl -alすると、
さらに以下のような設定が提示されるかもしれません。
\begin{verbatim}
allownet -protocol tcp -port 6353 server;	
\end{verbatim}
これは、vsftpdがTCP 6553ポートを使ってサーバーとして振る舞おうとしている
ことを言っています。が、ポート番号は毎回変わります。なので、以下のように
1024以上のポートを使えるよう設定します。
\begin{verbatim}
allownet -protocol tcp -port 1024- server;	
\end{verbatim}
設定を反映し、さらにテスト動作を、アクセス拒否がでなくなるまで繰り返しま
す。最後にenforcingモードにして、テストをして正しく動作することを確かめ
ます。
\begin{verbatim}
#setenforce 1
\end{verbatim}
%%%enforcingモードでテスト
%コンパイルエラーの見方
さて、ここまでの加方法で、概ね設定できるかと思います。
ログインユーザのセキュリティを高めるための機能として、SPDLはRBACもサポー
トしています。RBACについては、「RBACガイド」を参照
してください。

\section{その他の注意点}
\begin{enumerate}
 \item ファイルの移動\\
       ファイルAを別のディレクトリBに移動した場合，ディレクトリBにアクセスできるドメ
       インが、移動後のAにアクセスできなくなることがあります。
       ファイル移動時、「ファイルAに対するアクセス権限」を引き継ぐからで
       す（詳しくは後述)。このようなトラブルを解決するにはrestoreconコマ
       ンドを使う必要があります。
\begin{verbatim}
* 具体例：ホームページのアップロードの場合
Apacheが移動したファイルにアクセスできないことがあります
# pwd
/root/homepage/index.html
# mv index.html /var/www/html
# restorecon /var/www/html/index.html
\end{verbatim}
ここで、最後のrestoreconコマンドを忘れると、Apacheは/var/www以下にアクセ
       スできるように設定されてたとしても、index.htmlにアクセスできませ
       ん。
       なぜなら、httpd\_tは、/root/index.htmlにアクセスできませんが、こ
       れがファイル移動後も継承されているからです。
       これを修正するにはrestoreconコマンドをする必要があります。
       これでも問題が解決できない場合は特殊な場合です。audit2spdlで設定
       を追加する必要があります。
 \item ファイルの新規作成\\
       新規作成されたファイルのアクセス権限は、ディレクトリから引き継が
       れます。次の例を見てください。以下の設定が存在したとします。
       \begin{verbatim}
domain foo_t;
allow /foo/bar/** r,s;
allow /foo/bar/test.txt r,w,s;
       \end{verbatim}
foo\_t は、/foo/bar以下に読み込み可能で、/foo/bar/test.txtに書き込み可能
       です。\\
/foo/bar/test.txtが、設定時に存在しなかったとし、設定後にtest.txtに新規
       作成されたとします。
foo\_tは、/foo/bar/test.txtに読み込みアクセスしかできません。/foo/barの
       アクセス権を引き継ぐからです。
この状況を直すには、
\begin{verbatim}
restorecon -R /foo/bar	
\end{verbatim}
をする必要があります。
 \item restoreconはなぜ必要?\\
       SELinuxは、ファイルなどのリソースを「タイプ」を呼ばれるラベルで識
       別しています。
       タイプの名前は、ファイル名の「\slash」を「\_」に置換した名前になってい
       ます。
       mvコマンドをするときは、ラベルは保存されます。ファイルが新規作成
       された時は、タイプはディレクトリのものを引き継ぎます。ファイルと
       タイプの関連付けをrestoreconコマンドを使うことで直す必要があるの
       です。

 \item cron ジョブ\\
       Cronジョブは、unconfinedなドメインで動きます。cron jobのアクセス
       制御を行いたい場合は、system\_crond\_t.spを編集し、
 {\it allowpriv all;}を削る必要があります。ただし、cronジョブを正しくア
       クセス制御するのは難しいことに注意が必要です。

 \item 消去、生成が繰り返されるファイル\\
       消去、生成が繰り返されるファイルについては、アクセス制御が思った
       ようにいかない場合があります。次の例を見てください。
\begin{verbatim}
domain foo_t;
allow /foo/bar/** r,s;
allow /foo/bar/test.txt r,w,s;
\end{verbatim}
こう設定したとすると、test.txtが消去され、再度test.txtが生成された場合、
       test.txtのアクセス権限は所属ディレクトリのものを継承しますから、
foo\_tは、test.txtを読み込みしかできません。
restoreconコマンドでこれを直すことができるのですが、またtest.txtが消去、
       生成されると、さらにrestoreconをしなければなりません。\\
ディレクトリに対するアクセス権限と違うファイル、かつそれが消去、生成が繰
       り返される場合は、アクセス制御がうまく設定できないことになります。\\
これを解決するには以下のような方法があります。
\begin{enumerate}
 \item ファイル毎のアクセス制御をあきらめ、ディレクトリ単位のアクセス制
       御をする\\
つまり、
allow /foo/var/** r,s,{\it w}.
のように、/foo/var全体に書き込み権限を与えてやれば問題ありません。
しかし、書き込み可能な範囲が広がってしまいます。
 \item allowtmpを利用\\
      このような、生成消去を繰り返すファイルのアクセス制御をするために、
       SPDLにはallowtmpという設定要素が用意されています。今回の場合は次
       のように設定することになります。
\begin{verbatim}
       allowtmp /foo/bar -name auto  r,w,s;	
\end{verbatim}
       allowtmpを使うことで、ファイルを「ラベル」を使って識別できるよう
       になります。
       上の文にて、foo\_tが、/foo/bar以下に作成したファイルは、
       foo\_foo\_bar\_tという名前のラベル(-name autoで命名がされます。
       foo\_t + /foo/bar = foo\_foo\_bar\_t という規則です)が付与され、
       そして、foo\_tは、このラベルに対し、r,w,sアクセス可能、ということ
       になります。\\
       このようにすることによって、test.txtが/foo/barディレクトリに消去、
       生成を繰り返されたとすると、test.txtには、foo\_foo\_bar\_tという
       ラベルが常に付与されます。そして、このラベルを使ってSPDLから設定
       することができます。\\
       例えば、他のドメインから、このラベルが付いたファイルにアクセスし
       たい場合は、
       \begin{verbatim}
	allow foo_foo_bar_t r;
       \end{verbatim} 
のように書きます。
       ちなみに、allowtmpでは、SELinuxのファイルタイプ遷移が使われてます。\\
       デフォルトで用意されているポリシーでは、allowtmpは、/etc/mtabのア
       クセス制御や、/tmp,/var/tmp以下の一時ファイルのアクセス制御に使わ
       れています。
\end{enumerate}
 \item /devディレクトリ以外のデバイスを使う\\
       デバイスファイルは、システムに対して致命的な影響を及ぼすため、
       SPDLでも特に注意深く取り扱われています。
       デフォルトで用意されているポリシでは、デバイスは、/devディレクト
       リに存在すると設定されています。つまり、/devディレクトリ以外のデ
       バイスに対して、allowでアクセス許可を設定しても、無視されてしまい
       ます。\\
       /devディレクトリ以外のデバイスを使いたい場合は、allowdev文を使う
       必要があります。例えば、/var/chroot/dev/nullにアクセスしたい場合
       は、/var/chroot/dev/nullにアクセスする設定を記述する前に、
       \begin{verbatim}
	allowdev -root /var/chroot/dev;	
       \end{verbatim}
       のように、デバイスの格納されるディレクトリを指定しておhく必要があ
       ります。
 \item シンボリックリンクを含むファイル名\\
       シンボリックリンクを含むファイル名は無視されます。
例えば、\\
      allow /etc/init.d/httpd r;\\
は無視されます。init.d は、 rc.d/init.dのシンボリックリンクだからです。
 \item ハードリンクの扱い\\
       Linuxシステムでは、ハードリンクを使うことで、ファイルの中身を複数
       のファイル名で参照することができます。ハードリンクは、デフォルト
       ではほとんど使われていないため、以下の内容を気にする場面はほとん
       ど現れませんが、セキュリティ上知っておいたほうがいいでしょう。\\
       SPDLでは、ハードリンクは以下のルールで処理されます。\\
       {\it ファイルの中身が複数のハードリンクで参照される場合、元々存在
       したファイル名を記述する必要がある。それ以外のファイル名が指定さ
       れた場合は無視される。}\\
       例えば、/etc/shadow と/var/chroot/etc/shadowがハードリンクされて
       いたとします。/etc/shadowが元々存在していたとすると、/etc/shadow
       (と/var/chroot/etc/shadow)の中身を見るためには、allow
       /etc/shadow rと記述する必要があります。allow /var/chroot/etc/shadow r
       と記述しても無視されます。\\
       ハードリンクが複数存在する場合、どのファイル名を「元々存在するファ
       イル名」とするかの基準が気になるところです。以下の基準で
       「元々存在するファイル名」が判定されます。以下で出てくる例では、
       /etc/shadow, /var/shadowがハードリンクされたファイルだと仮定しま
       す。\\
       \begin{enumerate}
	\item 全ポリシ中で、一つのファイル名に対する設定しか書かれていな
	      い場合、そのファイル名が「元々存在するファイル名」になりま
	      す\\
	      例: allow /etc/shadow rがある場所で記述されているとします。
	      そして、/var/shadowを使った設定はどこにも記述されていない
	      とします。この場合は、/etc/shadowが、元々存在するファイル
	      名として取り扱われます。
	\item 複数のファイル名に対する設定が記述されていた場合、名前が一
	      番若いものが、「元々存在するファイル名」になります。\\
	      例: allow /etc/shadow r,allow /var/shadow r; という設定が
	      記述されていたとします。この場合、「/etc/shadow」が、「元々
	      存在するファイル名」になります。なぜなら、/etc/shadowのほ
	      うが名前が若いからです。
	\item ハードリンクされたファイル名を使った設定がどこにも記述され
	     てないときは、所属ディレクトリ名を比較して、所属ディレクト
	      リ名が最も大きいものが「元々存在するファイル名」となります。\\
	      例: /etc/shadow, /var/shadowを使った設定がどこにも記述され
	      ていない場合、/var/shadowが「元々あるファイル名」となりま
	      す。なぜなら、/var/ $>$  /etcだからです。
       \end{enumerate}
       しかし、どのハードリンク名が「元々存在するファイル名」か分からな
       い場合は、全ての名前を使う手もあります。例えば、
\begin{verbatim}
allow /etc/shadow r;
allow /var/shadow r;
\end{verbatim}
のように記述した場合、どちらかの設定は無視されるだけで、無害です。\\
       以上のハードリンクの取り扱いは、パス名ベースのセキュリティの「抜
       け穴」を防ぐために必要なものです。
       この取り扱いがなかったとすると、
       例えば、/etc/shadowのハードリンクが、なんらかの手で
       /var/www/html/shadowに作られてしまうと、Webサーバーから
       /etc/shadowの中身を覗けてしまうことになります。これを防ぐために、
       ハードリンクされたファイルの中身にアクセスするには、「一つのファ
       イル名」しか使えないようにする必要があるわけです。パス名ベースの
      セキュリティの問題点については、\\
       http://securityblog.org/brindle/2006/04/19 \\
       に詳しいです。

\end{enumerate}

\section{Tips}
\begin{enumerate}
 \item Webアプリケーション(CGI)を安全に設定する\\

デフォルトでは、CGIは、httpd\_tドメイン(Apache Webサーバのドメイン)で動
作します。これは、サブプログラムのドメインは、親プログラムのドメインと同
じになるというSELinuxの仕様によるものです。
CGIのドメインを変えたい場合は、「domain\_trans」というものを使って設定を記述する必要があります。
具体例を解説します。\\
CGIスクリプトが、/var/www/cgi-binにあると仮定し、cgi\_tドメインで走らせ
たいとします。
cgi\_t.spを以下のように作ります。
\begin{verbatim}
{
domain cgi_t;
domain_trans  httpd_t /var/www/cgi-bin/**;
include common-relaxed.sp;
##### allowxxx will be here...
}
\end{verbatim}

program文は、unconfinedドメインから起動したプログラムにドメインを割り当
てるものでした。domain\_trans文は任意のドメインから起動されたプログラム
にドメインを割り当てるものです。
\begin{verbatim}
domain cgi_t;
domain_trans  httpd_t /var/www/cgi-bin/**;	
\end{verbatim}
は、httpd\_tドメインで動いているプログラムが、/var/www/cgi-bin以下のプロ
グラムを実行した場合、cgi\_tドメインを割り当てる、という意味になります。
\\
なお、PHPについては、httpd\_tドメイン以外で動作させることはできません。
PHPは、通常の実行とは異なる方法で処理されているからです。

\item deny\\
{\it deny}という設定要素を使うことで、重要なファイルをブラックリストに登
録し、設定ミスの防止に利用することができます。以下の例を見てみましょう。
\begin{verbatim}
{
domain foo_t;
deny /etc/shadow;
allow /etc/** r,s;
}
\end{verbatim}
foo\_tが、/etc以下の全ファイルに読み込みできるように設定されていますが、
/etc/shadowにアクセスすることができません。
/etc/shadowにアクセスするには、 {\it allow /etc/shadow}と明示的に記述す
る必要があります。なお、デフォルトではinclude/common-relaxed.spにいくつ
かのファイルがdenyが登録されています。
\end{enumerate}

\end{document}


