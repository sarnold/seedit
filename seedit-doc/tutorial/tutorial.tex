\documentclass{article}
\usepackage[dvipdfm]{graphicx}
\title{Tutorial of SELinux Policy Editor(seedit)(for Ver 2.0))}
\author{Yuichi Nakamura \thanks{ynakam@gwu.edu}}
\begin{document}
\def\labelenumi{(\theenumi)}
\maketitle
\tableofcontents
\newpage


%このガイドは、「targeted」なポリシを書くためのガイドにすぎない。もっと
%     詳細なポリシを書きたい人は別のドキュメントを参照

\section{What is SELinux Policy Editor}
SELinux is included in many distros, but it has been disabled by many users
because of they feel SELinux is too difficult. 
SELinux Policy Editor(seedit) is a tool that make SELinux easy.
seedit is composed of Simplified Policy and utilities that handle
Simplified Policy.The main component is Simplified Policy.
Simplified Policy is a SELinux policy that is described by Simplified
Policy Description Language(SPDL).SPDL resolves difficulty of SELinux. 
SPDL simplifies SELinux by reducing number of permissions and hiding
labels. 
Following is a example of policy described by SPDL.
\begin{verbatim}
{
domain httpd_t;
program /usr/sbin/httpd;
...
allow /var/www/** r,s;
allownet -protocol tcp -port 80 server;
...
}	
\end{verbatim}
You can easily understand what the policy says. Customize is also
easy, because of helper tools. 
It's original version was developed by Hitachi Software(http://www.selinux.hitachi-sk.co.jp/).
It has been re-designed and almost re-written by Yuichi
Nakamura(ynakam@gwu.edu) since version 1.0.

\section{Background of SELinux}
You have to be familiar with some SELinux background, especially
following.
\begin{enumerate}
 \item TE(Type-Enforcement)\\
       Access control model of SELinux is called TE. In TE, process is
       given {\it domain}. SELinux decides access control based on
       configuration file called {\it policy}. In policy , {\it What
       kind of resource a domain is allowed to access ?} is described.
       To identify resources, SELinux uses label called {\it type}, but
       you do not have to be worry about {\it type}, because it is hidden
       in seedit world.
       By giving proper domain to application and configuring domain
       properly, the application  have least privilege. 

 \item Enforcing/permissive mode\\
       SELinux have two mode, enforcing and permissive mode.
       Enforcing mode is normal mode. Access control is
       effective.        \\
       Permissive mode is a test mode. Even if there is a access that is
       denied by SELinux, it is not actually denied, but only written to
       log. In permissive mode, SELinux is effectively disabled, but
       useful to test the behavior of access control.
       To see current mode, you can use {\it getenforce} command. To
       switch between enforcing/permissive mode, you can use {\it
       setenforce} command. The usage will appear later in the document.
 \item SELinux access denial log\\
      Access denial is outputted in /var/log/messages in Fedora
       Core5. In Fedora Core4 or using auditd service, it is outputted
       to /var/log/audit/audit.log.
\end{enumerate}

\section{Install}
\subsection{Install from RPMs}\label{sec:rpm}
You can easily install from RPM
\begin{enumerate}
 \item Install required package\\
       You need checkpolicy package.
\begin{verbatim}
# yum install checkpolicy		
\end{verbatim}
    \item Obtain files\\
Download seedit-converter-2.0.x.rpm and seedit-policy-2.0.x-(your
	  distro).rpm
From below URL.
\begin{verbatim}
http://sourceforge.net/project/showfiles.php?group_id=135756	
\end{verbatim}
If you use Fedora Core 5, download seedit-converter-2.0.x-FC5.rpm and
       seedit-policy-2.0.x-FC5.rpm.\\
GUI is optionally available. The filename is seedit-gui-2.0.x.noarch.rpm.


 \item Install rpms
Install rpm and restart by following commands.
\begin{verbatim}
$ su 
# rpm -ivh seedit-*.rpm
# reboot
\end{verbatim}
 \item Initialization\\ \label{item:init}
When system restarts, some relabeling process run. It takes some
	  minutes. When you log in, initialize policy and reboot again by following
	  command.
\begin{verbatim}
# seedit-load
# reboot
\end{verbatim}
 \item That's it!\\
You can make sure seedit is installed by following command.
\begin{verbatim}
# sestatus
SELinux status:                 enabled
Current mode:                   permissive
Mode from config file:          permissive
...
Policy from config file:        seedit
\end{verbatim}
Note that simplified policy is installed as {\it permissive} mode.
In {\it permissive} mode, SELinux is not protecting your system. It is
 only a test mode. To be a enforcing mode, see \ref{sec:mode}.

\item Uninstall\\
If you want to uninstall. Do following.
\begin{verbatim}
# rpm -e seedit-policy seedit-converter	
# reboot
\end{verbatim}
You system will restart as SELinux targeted policy(Fedora Core5 default)
and permissive mode(SELinux is effectively disabled).
\end{enumerate}

\subsection{Installing from source}
\begin{enumerate}
 \item Obtain files\\
Download seedit-converter-1.4.x.tgz and seedit-policy-1.4.x.tgz
From below URL.
\begin{verbatim}
http://sourceforge.net/project/showfiles.php?group_id=135756	
\end{verbatim}
 \item Build and install\\
\begin{verbatim}
# tar czvf seedit-*.tgz
# cd seedit-converter
# make install
# cd .. 
# cd seedit-policy
# make install
# touch /.autorelabel
# reboot
\end{verbatim}
Next is the same as \ref{sec:rpm} (\ref{item:init}).\\
 \item uninstall\\
You can go back to Fedora Core5 default by following.\\
Modify /etc/selinux/config like below.
\begin{verbatim}
SELINUXTYPE=seedit
-->
SELINUXTYPE=targeted
\end{verbatim}
And 
\begin{verbatim}
#touch /.autorelabel
#reboot	
\end{verbatim}
\end{enumerate}

\subsection{What's affected?}
 In this installation process ,
/etc/selinux/config is changed like below.
\begin{verbatim}
SELINUX=permissive	
SELINUXTYPE=seedit
\end{verbatim}
Our system does not interfere with other existing system components
except that.

\subsection{Attention to old version users}
\begin{itemize}
 \item Configuration file is not compatible with old version.
 \item To upgrade from old version, you have to do 
       \begin{verbatim}
	# rpm -e seedit-converter seedit-policy
	# rm -rf /etc/selinux/seedit
       \end{verbatim}
 
\end{itemize}

\section{Overview of GUI}
You can manage SELinux from SELinux Policy Editor's GUI.
GUI is X Window based. 
In this tutorial, how to use GUI is shown first. You can also manage
from command line, it is shown later.\\
You can launch GUI from Gnome menu. Choose Desktop $\rightarrow$ Manage $\rightarrow$ SELinux
Policy Editor.
You can also launch  GUI, by typing seedit-gui.\\
You will see window {\it SELinux Policy Editor Control Panel}.
In the control panel, you will see icons(you will see buttons instead of
icons in CentOS 4) like figure \ref{fig:controlpanel}.\\

\begin{figure}[h]
\caption{SELinux Policy Editor Control Panel}\label{fig:controlpanel}
\includegraphics*{images/controlpanel.png}
\end{figure}

By double-clicking icon, management windows  open. 
What you can do by double-cliking icons is summarized in following.
\begin{itemize}
 \item Status\\
       The usage is shonw in section \ref{sec:seedit-status}.
       \begin{itemize}
	\item See status of SELinux, such as SELinux mode, domains for
	      runnning  process, domains for network process.
	\item Change SELinux mode
       \end{itemize}
 \item Manage Domain
       \begin{itemize}
	\item Create new domain
	\item Remove domain, disable domain
       \end{itemize}
 \item Generate Policy
       \begin{itemize}
	\item Generate policy from access log.
       \end{itemize}
 \item Edit policy
       \begin{itemize}
	\item Edit policy by text editor. The text editor has some
	      useful features.
       \end{itemize}
 \item Apply policy,Relabel
       \begin{itemize}
	\item Load policy manually\\
	      Policy is load automatically in GUI, but you can do it manually.
	\item Initialize all file labels\\
	\item Run restorecon command\\
       \end{itemize}
\end{itemize}



\section{See what's happening on your system}
\subsection{Where is policy?}
Simplified policy(policy described by SPDL) is located at
/etc/seedit/policy, it is explained in later section.
Simplified Policy is converted into SELinux
policy by seedit-load command(inside the command, seedit-converter runs,
it does main task), and SELinux Policy(binary SELinux policy,file\_contexts is generated).
 Generated SELinux policy is located at
/etc/selinux/seedit/policy, generated file\_contexts is at /etc/selinux/seedit/contexts/files.
Usually, you do not have to care  about generated policy.
\subsection{Default policy}
Installed simplified policy is a targeted one. Not strict policy.
It does not include RBAC support. Only selected daemons are protected.
Simplified policy can support RBAC and more strict policy, but such
policies are under construction :-) .About RBAC, it is ready to use, if
you are interested in it, see RBAC guide.

\subsection{seedit-status(GUI)}\label{sec:seedit-status}
Some processes are given domain and behavior is confined.
To know what is confined and what is unconfined, you check from GUI.
From control panel, select {\it Status}.





\subsection{seedit-unconfined(Command)}
You can also do the same task from seedit-unconfined command.

\subsubsection{See running process}
You can see status of processes by seedit-unconfined -e.
You have to be root to obtain correct result.
Following is example output.
\begin{verbatim}
$ su -
# seedit-unconfined -e
Current SELinux mode: permissive ----(1)
PID     Comm    Domain
1       init    Unconfined(init_t) ---(2)
...
1853    sshd    Confined by sshd_t ---(3)
\end{verbatim}
(1) is current SELinux mode this says permissive mode. Note again that system
    is not actually protected by SELinux in permissive mode.(2) says
    process init is not unconfined, and given unconfined domain
    init\_t. {\it unconfined} means: the given domain is allowed
    everything, and effectively not protected by SELinux. (3) says sshd
    is given sshd\_t domain and sshd\_t domain is configured to confine
    behavior of sshd.\\
You can also see domains by ps -eZ command, but it does not tell us what
    kind of domains are
    unconfined. /etc/selinux/seedit/policy/unconfined\_domains will tell
    you what kind domains are unconfined.

\subsubsection{See network process}
You can see status of network process(that is waiting network
connection), by seedit-unconfined -n. 
It is important to know status of network process. Because attackers use
network process to intrude. 
Sample output is following.
\begin{verbatim}
#seedit-unconfined -n 
Current SELinux mode: permissive ----(1)
/usr/sbin/smbd  Unconfined(initrc_t) -- (2)
/usr/sbin/sendmail.sendmail     Confined by sendmail_t --(3)
...	
\end{verbatim}
It is like AppArmor's unconfined command. 
(1) is current SELinux mode. After network programs are shown.
(2) says smbd is not confined. (3) says
sendmail is confined by domain sendmail\_t.
From above, You have to be especially careful to smbd. 
If you create domain, you can confine it, or you may decide not to run
the service.

\subsection{Switching enforcing/permissive mode}\label{sec:mode}
After install system is permissive mode. you can switch to enforcing mode by following.
\begin{verbatim}
# setenforce 1
# getenforce 
enforcing
\end{verbatim}
If you want to be enforcing mode in boot time, you have to modify
 /etc/selinux/config like following. It is strongly recommended when you
 use real system.
\begin{verbatim}
SELinux=permissive
-->
SELINUX=enforcing
\end{verbatim}

\section{Then, what should we do?}
Now you know SELinux status of your system(what's
confined,unconfined). What you have to do after that can be summarized like below. 
\begin{enumerate}
 \item Unconfine applications\\
   If you find application does not run due to SELinux access denial,
       you can choose unconfine such application.It's easy. You can see how to in
       section \ref{sec:unconfine}.
 \item Modify policy\\
       If you find application does not run due to SELinux access
       denial, but still want to confine application, you can modify
       policy.  See section \ref{sec:policy}.
 \item Confine more applications by creating domains\\
       If you want to confine unconfined applications, you can prepare
       domain for them. See section \ref{sec:policy}.
\end{enumerate}

\section{Unconfine applications}\label{sec:unconfine}
You can unconfine application by 2ways. Use boolean or remove config file.

\subsection{Use boolean}
If you know SELinux boolean, it's very easy.
For example, confined domain name is httpd\_t, then turn on
httpd\_disable\_trans boolean and restart daemon.
\begin{verbatim}
Example: 
# setsebool -P httpd_disable_trans 1
# /etc/init.d/httpd restart
# seedit-unconfined -e
Current SELinux mode: enforcing
PID     Comm    Domain
1111     httpd    Unconfined(initrc_t)
\end{verbatim}
You can confine again by turning off boolean
\begin{verbatim}
Example: 
# setsebool -P httpd_disable_trans 0
# /etc/init.d/httpd restart
# seedit-unconfined -e
Current SELinux mode: enforcing
PID     Comm    Domain
1111     httpd   Confined by httpd_t domain
\end{verbatim}
\subsection{Remove config file}
Config file of domain is located
/etc/seedit/policy/{\it domain name}.sp.
If you remove it and restart application, you can unconfine application.
See example below.
\begin{verbatim}
Example: 
# cd /etc/seedit/policy
# mkdir unused
# mv httpd_t.sp unused
# seedit-load
# /etc/init.d/httpd restart
# seedit-unconfined -e
Current SELinux mode: enforcing
PID     Comm    Domain
1111     httpd    Unconfined(initrc_t)
\end{verbatim}
If you want confine again, place config file to /etc/seedit/policy dir.
\begin{verbatim}
Example: 
# cd /etc/seedit/policy
# mv unused/httpd_t.sp .
# seedit-load
# /etc/init.d/httpd restart
# seedit-unconfined -e
...
\end{verbatim}
\section{Lets' edit policy}\label{sec:policy}
\subsection{Where is policy?}
Our simplified policy is located at /etc/seedit/policy
directory. In the directory, files named {\it domain name}.sp are
located. 
\subsection{Policy syntax overview}
Simplified policy is described in syntax called Simplified Policy Description
Language(SPDL). For detail, see other document(SPDL specification).
You do not have to understand its full specification, because there is a
helper tool when you describe policy. But it is better for you to be
able to understand policy. \\
 Let's see overview of SPDL by looking at example.
Figure \ref{policyexample} shows policy for Apache web server.

\begin{figure}
\caption{Typical example of policy: Policy for Apache Web server}\label{policyexample}
\begin{verbatim}
     1  {
     2  domain httpd_t;
     3  program /usr/sbin/httpd;
     4  include common-relaxed.sp;
     5  include daemon.sp;
     6  include nameservice.sp;
     7  allow /var/www/** r,s;
     8  allow /var/log/httpd/** r,a,s;
     9  allow /etc s;
    ...<snip>..
    10  allownet -protocol tcp -port 80,443 server;
    11  allowpriv netlink;
    12  }	
\end{verbatim}
\end{figure} 

\subsubsection{Give domain to application}
Line 2 and 3 is configuration that gives domain to application .
Line 2 names domain as httpd\_t. Access rights for the domain is
configured. By default domain has {\it no} access rights, by configuring to
allow access to resources, domains can access resources.\\

line 3 means we will give httpd\_t
domain to /usr/sbin/httpd. By them, when /usr/sbin/httpd is executed, it
is confined by httpd\_t domain.
\begin{itemize}
 \item Note to experts\\
       To give domain we are using SELinux's domain transition
       mechanism. By line 2 and 3, domain transition from unconfined
       domain(such as initrc\_t) to httpd\_t, and entry point is
       /usr/sbin/httpd(which is labeled automatically by SPDL
       compiler).  So you have to notice that domain transition does
       not happen from confined domain.
\end{itemize}
\subsubsection{Import typical configuration}
By line 4,5,6 configurations common to applications are imported.
To see what is imported, see files in include directory.
For example, {\it include include nameservice.sp;}, configuration that
is described in include/nameservice.sp is imported. Read access to files such
as /etc/hosts are allowed.

\subsubsection{Allow access to file}
Line 7-10 allows access to files. File name and permissions are described.
For filename, you can use grab like below. 
\begin{verbatim}
directory/* : means files under directory, not include subdirectory.
directory/**: means files under directory, including files under
		subdirectory.
\end{verbatim}
File name that starts with  \textasciitilde ~ represents
home directory(Not including /root).
\begin{verbatim}
~/public_html/**
\end{verbatim}
means public\_html directories under each user's home directories(except
/root).


You can specify following permissions.
\begin{itemize}
 \item Basic permissions
       \begin{itemize}
	\item s\\
	      Search.Permission to search file tree.i.e. Read file name list
	      in directory. For file, it means nothing.
	      
	\item  r\\
	      Read files.
	\item x\\
	      Execute files.
	\item  w\\
	      Write. This includes write,append,create,delete files.
       \end{itemize}
 \item Detailed permissions\\
       w permission is allowing too much, if you want more security, 
       w permission can be splitted into 5.
       \begin{itemize}
	\item a\\
	      Append.
	\item o\\
	      Overwrite. This means, write open file.
	\item c\\
	      Create. Create files.
	\item e\\
	      Erase. Delete files.
	\item t\\
	      Setattr.Modify file attribute(not including file security attribute).
       \end{itemize}       
\end{itemize}
Now you can understand line 7-9.
\begin{itemize}
 \item Line7: http\_t can see file lists and read all files under
       /var/www, including sub-directories.
 \item Line 8:
       http\_t can see file lists, read/append all files under
       /var/log/httpd, including sub-directories.
 \item Line 9:
       httpd\_t can see file list in /etc. Can not do anything files
       in /etc directory. Because /etc/* is not described.
\end{itemize}

\subsubsection{Allow access to network}
Access to network can be described by simplified policy.
By line 10, httpd\_t is allowed to behave as a server using tcp 80,443 port.\\
If you want to allow httpd\_t to connect MySQL(TCP 3306), you have to
specify following.\\
allownet -protocol tcp -port 3306 client;\\
You can use -1023, 1024-, and * for port number. -1023 means all
wellknown ports. 1024- means all ports over 1024, and * means all port number.


\subsubsection{Allow other privilege}
Other important operations not related to files and networks are restricted by
SELinux. You can use {\it allowpriv name\_of\_privilege;}.
For example, usage of netlink socket(it is used to communicate with
kernel) is allowed in line 11.

\section{Adding policy}
\subsection{audit2spdl}
If you find confined application run due to SELinux denial, you have to
add policy. We have utility called audit2spdl to help you.
The usage is easy.
When auditd is not running(Fedora Core5 default),
\begin{verbatim}
# audit2spdl -dl
\end{verbatim}
When auditd is running(Fedora Core4 default)
\begin{verbatim}
# audit2spdl -al
\end{verbatim}
You can read log by specifying filename, 
\begin{verbatim}
# audit2spdl -l -i /var/log/messages 
\end{verbatim}
This command translate SELinux log denial to simplified policy.
It is recommended to use auditd service if it is prepared for your
distro. For Fedora Core 5, you can install auditd by following commands.
\begin{verbatim}
#yum install audit
#chkconfig auditd on
#/etc/init.d/auditd start
\end{verbatim}


Following is sample output.
\begin{verbatim}
#audit2spdl -dl
.... It takes some time...
-------------------------
#SELinux deny log:
audit(1146162965.963:16): avc:  denied  { read } for  pid=6653 
comm="vsftpd" name="vsftpd.conf" dev=hda3 ino=584775 
scontext=user_u:system_r:ftpd_t 
tcontext=system_u:object_r:default_t tclass=file
#Suggested configuration
File ftpd_t.sp:
allow /etc/vsftpd/vsftpd.conf  r;
-------------------------
...
\end{verbatim}

Above says you have to add 
\begin{verbatim}
allow /etc/vsftpd/vsftpd.conf  r;	
\end{verbatim}
to ftpd\_t.sp to resolve SELinux access denial.


\subsection{Add policy}
In above example, 
open /etc/seedit/policy/vsftpd.sp.
and add allow /etc/vsftpd/vsftpd.conf  r;	
between ${}$, like below
\begin{verbatim}
{
domain vsftpd\_t
program /usr/sbin/program;
allow ....
<add here!!>

}
\end{verbatim}
After adding file, you have to notice it to SELinux kernel. Type seedit-load.
\begin{verbatim}
#seedit-load
seedit-load: Success
\end{verbatim}
You can see progress of seedit-load by -v option like below
\begin{verbatim}
# seedit-load -v
mkdir -p ./sepolicy;
m4 -s ./simplified_policy/*.sp >./simplified_policy/all.sp;
/usr/bin/seedit-converter -i ./simplified_policy/all.sp -o 
./sepolicy -b ./base_policy -I ./simplified_policy/include ;
.................

cp /etc/selinux/seedit/contexts/files/file_contexts.all 
/etc/selinux/seedit/contexts/files/file_contexts.all.old
seedit-load: Success	
\end{verbatim}
In above case, you can add 
\begin{verbatim}
allow /etc/vsftpd/* r;.	
\end{verbatim}
It is a little different from that suggested by audit2spdl.
Because system administrate knows /etc/vsftpd is vsftp's configuration
directory, so it is more effective to allow access whole /etc/vsftpd directory.

\subsection{Advanced topic:Notice about audit2spdl}
\begin{enumerate}
 \item Not best security\\
audit2spdl not always suggest best solution.
You have to review suggested configuration carefully.
For example, audit2spdl does not generate detailed file
permission(o,a,c,e,t), but generate w. \\
To generate permission o,a,c,e,t, use s option, like audit2spdl -dls .


\item Fail to suggest\\
In special case, suggesting configuration fails, following message
       appear.
\begin{verbatim}
#Failed to generate, because failed to obtain fullpath.	
\end{verbatim} 
In SELinux log, full-path is not contained. To obtain full path audit2spdl
       is doing some works, but it sometimes fail. 
To obtain full-path in all cases, you have to use auditd.
auditd is not installed in Fedora Core 5.
You can use auditd like below.
\begin{verbatim}
#yum install audit
#chkconfig auditd on
#/etc/init.d/auditd start
\end{verbatim}
The use audit2spdl -al, and try again.
It is also faster than audit2spdl -dl.


\end{enumerate}


\section{Creating domain}
Let's see by example to create domain ftpd\_t for vsftpd, and confine behavior
of vsftpd. By following this example you'll be able to prepare domain
for other programs.
Generally, process of creating domain is following.
\begin{enumerate}
 \item Create template\\
 \item Check domain\\
 \item Test run and add policy\\
\end{enumerate}

\subsection{Create template}
You can create template configuration by seedit-template command.
Usage is following.
\begin{verbatim}
seedit-template -d <domain> -e <path to application> -o <output>
\end{verbatim}
Following is output for us.
\begin{verbatim}
# seedit-template -d vsftpd_t -e /usr/sbin/vsftpd
{
domain ftpd_t;
program /usr/sbin/vsftpd;
include common-relaxed.sp;
include daemon.sp;
include nameservice.sp;
}
\end{verbatim}
Template configuration is generated. In this, domain is named, and given
to /usr/sbin/vsftpd. By {\it include }, access rights commonly used for
daemons are imported.
You have to save this configuration under
/etc/seedit/policy/ftpd\_t.sp.
Note that file name must be {\it domain-name}.sp, otherwise seedit-load
fails. \\
Save above configuration to /etc/seedit/policy/ftpd\_t.sp.\\


\subsection{Check domain}
Load simplified policy by following.
\begin{verbatim}
#seedit-load
\end{verbatim}
And switch to permissive mode, because vsftpd will fail to work in
enforcing mode due to SELinux access denial.
\begin{verbatim}
#setenforce 0
#getenforce
Permissive
\end{verbatim}
Start vsftpd and check domain of vsftpd by seedit-unconfined.
\begin{verbatim}
# /etc/init.d/vsftpd restart
# seedit-unconfined -e
10530   vsftpd  Confined by ftpd_t
\end{verbatim}
You will see vsftpd is running as ftpd\_t as above.

\subsection{Test run and add policy}
Let's  run application in permissive mode, and find out what access is
denied, and allow such access by audit2spdl.
In this article, we aim to develop policy for vsftpd to work as
Anonymous FTP server.
Let's test ftp like following.
\begin{verbatim}
$ ftp localhost
Name (localhost:ynakam): Anonymous
Password: <anything is OK>
...
and do something..
\end{verbatim}
And see log.
\begin{verbatim}
#dmesg	
\end{verbatim}
Various accesses are denied.
Let's audit2spdl.

\begin{verbatim}
#audit2spdl -dl
-------------------------
#SELinux deny log:
audit(1146179470.043:86): avc:  denied  { search } for  
pid=10904 comm="vsftpd" name="vsftpd" dev=hda3 ino=584772 
scontext=user_u:system_r:ftpd_t 
tcontext=system_u:object_r:etc_t tclass=dir
#Suggested configuration
File ftpd_t.sp:
allow /etc/vsftpd  s;
-------------------------

-------------------------
#SELinux deny log:
audit(1146179477.891:108): avc:  denied  { search } for  
pid=10911 comm="vsftpd" name="ftp" dev=hda3 ino=163477
 scontext=user_u:system_r:ftpd_t 
tcontext=system_u:object_r:var_t tclass=dir
#Suggested configuration
File ftpd_t.sp:
allow /var/ftp  s;
-------------------------
.....
\end{verbatim}
audit2spdl tells us various configuration should be added.
You might find following. 
\begin{verbatim}
-------------------------
#SELinux deny log:
type=AVC msg=audit(1148486754.718:36): avc:  denied  { lock } for  
pid=11763 comm="vsftpd" name="test.txt" dev=hda3 ino=163311 
scontext=user_u:system_r:ftpd_t tcontext=system_u:object_r:default_t
 tclass=file
#Suggested configuration
File ftpd_t.sp:
#Failed to generate, because failed to obtain fullpath.
#allow test.txt  r,s;
-------------------------
\end{verbatim}
It means failed to suggest configuration because audit2spdl failed to
guess fullpath for test.txt.
But you know fullpath of test.txt is /var/ftp/pub/test.txt.
So, you will add allow /var/ftp/pub/test.txt r,s;
\\

In my case, following are suggested at first test.
\begin{verbatim}
allow /etc/vsftpd  s;
allow /var/ftp  s;
allow /root  s;
allownet -protocol tcp -port 21 server;
allowpriv cap_sys_chroot;
allow /var/log/xferlog  r,w;
allow /etc/vsftpd/vsftpd.conf  r;
allow /etc/vsftpd/vsftpd.conf  s;	
\end{verbatim}
You can add them, but you will notice it is more effective 
To allow r,s to /var/ftp and /etc/vsftpd.
So, your ftpd\_t.sp will be following.
\begin{verbatim}
{
domain ftpd_t;
program /usr/sbin/vsftpd;
include common-relaxed.sp;
include daemon.sp;
include nameservice.sp;
# added by audit2spdl suggestion
allow /etc/vsftpd/**  r,s;
allow /var/ftp/**  r,s;
allow /var/log/xferlog  r,w;
allow /root  s;
allownet -protocol tcp -port 21 server;
allowpriv cap_sys_chroot;
}
\end{verbatim}
After seedit-load, test vsftpd again.
You will find access denial again.
By audit2spdl you will find like following.
\begin{verbatim}
allownet -protocol tcp -port 6353 server;	
\end{verbatim}
This says ftpd is trying to behave server using 6553 tcp.
But the port number varies time to time.So it seems ftpd requires to use all port over 1024.
You can add following.
\begin{verbatim}
allownet -protocol tcp -port 1024- server;	
\end{verbatim}
Then, test again and add policy until no access denial is outputted.
At last, switch to enforcing mode.
\begin{verbatim}
#setenforce 1
\end{verbatim}
Test vsftpd again.  \\
%%%enforcingモードでテスト
%コンパイルエラーの見方
\\
SPDL has advanced feature to configure more secure policy. 
For example, login user is not confined by default, 
to enhance login user security, you can use RBAC feature. 
About RBAC see RBAC guide.

\section{Other notices}
\begin{itemize}
       
 \item Notice about file move\\
       When you move file to another directory by mv command, you have to use restorecon
       command. Like below.
\begin{verbatim}
* Example: Upload homepage
# pwd
/root/homepage/index.html
# mv index.html /var/www/html
# restorecon -R /var/www/html	
\end{verbatim}
       If you forget last restorecon command, Apache will not be able to
       access /var/www/html/index.html, even if allow /var/www/** is
       described for httpd\_t.sp.
This is because, access right is inherited from source file in mv command. 
In this example, httpd\_t domain can not access under /root, but can
       read under /var/www.     After mv command, access rights to
       /var/www/html/index.html is the same as
       /root/homepage/index.html.
       To fix this situation you have to use restorecon command.
 \item File creation\\
       Newly created file inherits access rights from directory. See
       example below.\\
Assume following configuration exists.
       \begin{verbatim}
domain foo_t;
allow /foo/bar/** r,s;
allow /foo/bar/test.txt r,w,s;
       \end{verbatim}
foo\_t can read files under /foo/bar, and write /foo/bar/test.txt.
If /foo/bar/test.txt does not exist at the time of configuration, 
and after configuration /foo/bar/test.txt is created, foo\_t can {\it
       read} test.txt, because newly created test.txt inherits allow
       /foo/bar/**. This is confusing, but limitation of our
       implementation.\\
To fix this, you have to do 
\begin{verbatim}
restorecon -R /foo/bar	
\end{verbatim}
Then foo\_t can read/write test.txt.\\
 \item Why restorecon is necessary?\\
       SELinux internally identifies resources by label called {\it
       type}.
       When mv command, label is preserved.When file is newly created,
       type is inherited from belonging directory.
       We have to fix relationship between file and type by restorecon command.

 \item cron jobs\\
       Cron jobs are not confined. If you want to protect cron job,
       edit system\_crond\_t.sp, delete {\it allowpriv all;}. However,
       configuring cron jobs correctly will be very difficult.
       
 \item Dynamically created/deleted files\\
       For files that are dynamically created/deleted, access control
       sometimes do not work well.
       See example below.
\begin{verbatim}
domain foo_t;
allow /foo/bar/** r,s;
allow /foo/bar/test.txt r,w,s;
\end{verbatim}
In this, if test.txt is deleted, and created, test.txt inherits access
       right of directory.
So, foo\_t can read test.txt but can not write test.txt.
You can fix by restorecon, but when it is re-created, you have to do
       restorecon again..\\
Therefore, for files whose access right is different from directory, and they
       are deleted/created, access control does not work well.
To resolve this, you have following solutions.
\begin{enumerate}
 \item Give up controlling access for individual files\\
       you can write\\
allow /foo/var/** r,s,{\it w}.
By configuring above, if test.txt is deleted and created, foo\_t can
       write test.txt, however foo\_t can write other files under
       /foo/bar directory.
 \item Use allowtmp\\
       To protect such temporally files, SPDL supports allowtmp
       statement.
You can configure like following.
\begin{verbatim}
       allowtmp /foo/bar -name auto  r,w,s;	
\end{verbatim}
       By allowtmp statement, file can be identified by label in SPDL.
       This allowtmp statement means, files created under /foo/bar is
       labeled as foo\_foo\_bar\_t(-name auto generates label name based
       on domain and directory name, foo\_t + /foo/bar = foo\_foo\_bar\_t).
       And foo\_t can read, write files that have foo\_foo\_bar\_t label.
       By above, when  test.txt is deleted and created again, test.txt
       is given label(foo\_foo\_bar\_t) and identified by label.
       In allowtmp, file type transition in SELinux is internally used.\\
       If you want to access test.txt from other domain, you have to
       specify label not filename, like below.
\begin{verbatim}
	allow foo_foo_bar_t r;
\end{verbatim}
       In default policy,allowtmp is used to control access to /etc/mtab and temporally
       files under /tmp, /var/tmp.
\end{enumerate}
 \item Device files other than /dev\\
       Devices have critical impact to security, so it is treated specially.
       In default policy, device is assumed to exist under /dev.
       If you write allow statement for devices other than /dev
       directory, you can not access it.
       If you want to access devices other than /dev, you have to write
       allowdev statement.
       If you want to read access devices in /var/chroot/dev/null, 
       you have to write following, before describing allow /var/chroot/dev/null.
       \begin{verbatim}
	allowdev -root /var/chroot/dev;	
       \end{verbatim}
 \item Symbolic link\\
       Configuration to file that contains symbolic link is ignored.
       For example, \\
       allow /etc/init.d/httpd r;\\
       is ignored(init.d is symbolic link to rc.d/init.d).
 \item Hardlink\\
       In Linux system, contents of file can be refered by multiple name
       using hard link. Hardlink is rarely used recent distro, but you
       have to note about this if you want to preserve security.\\
       In SPDL, following rule exists about hard link.\\
       {\it If file has multiple hardlink, to access the file, you must
       specify originally existing file name. Other file names are ignored}\\
       For example, /etc/shadow and /var/chroot/etc/shadow is hardlinked,
       and /etc/shadow exists originally, to access contents of
       /etc/shadow, you have to use file name /etc/shadow. Configuration
       using /var/chroot/etc/shadow will be igonored. 
       If some domain(assume foo\_t ) want to read
       /var/chroot/etc/shadow, you have to configure {\it allow
       /etc/shadow r;}\\
       Next, there is a question, what is criteria of file name {\it
       originally} exist? Following is answer.\\
       In following, /etc/shadow and /var/shadow is assumed as
       hardlinked files.
       \begin{enumerate}
	\item If rule is described to one file name, the file nameis treated as
	      original.\\
	      Ex: allow /etc/shadow r; is described in some domain, but
	      rules using filename /var/shadow is not described,
	      /etc/shadow is treated as original.
	\item If rules are described to multiple hardlinked file name, the
	      filename that name is the youngest is treated as
	      original\\
	      Ex: allow /etc/shadow r, and allow /var/shadow r; are
	      described in some domains, /etc/shadow is treated as
	      original, because /var/shadow $>$ /etc/shadow.
	\item If rules are not described for hardlinked files, the
	      directory names that hardlinks exist are compared. The
	      file whose directory  name is oldest  is original.\\
	      Ex: /etc/shadow, /var/shadow do not appear in any domain.
	      Then /var/shadow is treated as original. Because
	      /var $>$ /etc.
       \end{enumerate}
       If you are not sure which hardlink is {\it original}, you can
       use all names. It means, you can describe
\begin{verbatim}
allow /etc/shadow r;
allow /var/shadow r;
\end{verbatim}
1 of 2 will be igored, and do no harm.
  
       Above treatment of hardlink is necessary to avoid a kind of {\it back door }
       of path name based configuration. Assume hard link to
       /etc/shadow is created by some trick under /var/www/html, without this
       behavior, apache web server can access contents of /etc/shadow
       via /var/www/html/shadow. To protect this, we must limit way to access
       hard link to 1.\\
       http://securityblog.org/brindle/2006/04/19 is good reference.\\

\end{itemize}


\section{Tips}
\subsection{Confining Web applications}
By default, CGI will run as httpd\_t domain. httpd\_t domain is a domain
for Apache Web Server, but domain is inherited to child programs by default.
If you want to change domain for CGI, you have to use domain\_trans element.
You can give CGI programs individual domain.
If you place your CGI in /var/www/cgi-bin, and give it cgi\_t domain,
create cgi\_t.sp like below.
\begin{verbatim}
{
domain cgi_t;
domain_trans  httpd_t /var/www/cgi-bin/**;
include common-relaxed.sp;
##### allowxxx will be here...
}

\end{verbatim}

For PHP, you {\it can not } change domain from httpd\_t. It is because
		PHP is internally executed not using exec system
		call. SELinux can not give domain for such case, unless
		PHP is extended to use SELinux system call.

\subsection{deny}
You can register important files in black list by {\it deny} element.
Following is example.
\begin{verbatim}
{
domain foo_t;
deny /etc/shadow;
allow /etc/** r,s;
}
\end{verbatim}
In above, foo\_t is allowed to all files by allow /etc/**, but can not
access /etc/shadow.
To access /etc/shadow, you have to write {\it allow /etc/shadow}
explicitly.
Some deny elements are written by default in include/common-relaxed.xp
\end{document}
